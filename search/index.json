[{"content":"求解绘制三角形问题 绘制三角形就是遍历每一个像素，然后，判断这个像素是否在三角形内部。\n但是万一，三角形很小，而屏幕很大，遍历每一个像素显然是非常低效的，在正式遍历前可以求出 Bounding Rect 来缩小范围：\n1 2 3 4 5 6 7 // Bounding Rect Vector2i min(0, 0); Vector2i max(width - 1, height - 1); min.x = std::max(min.x, std::min(p0.x, std::min(p1.x, p2.x))); min.y = std::max(min.y, std::min(p0.y, std::min(p1.y, p2.y))); max.x = std::min(max.x, std::max(p0.x, std::max(p1.x, p2.x))); max.y = std::min(max.y, std::max(p0.y, std::max(p1.y, p2.y))); 判断一个点是否在三角形内部，有很多方法，这里主要介绍重心坐标，因为这是图形学非常重要的一个知识点，而且也能非常好地解决这个问题。\n重心坐标（Barycentric Coordinate）的定义 假设平面上存在三角形的三个点 $a, b, c$，则平面上任意的点 $p$ 都可使用三角形的三个顶点表示：\n$$ \\begin{aligned} p \u0026amp;= a+\\beta(b-a)+\\gamma(c-a)\\cr p \u0026amp;= (1-\\beta-\\gamma)a+\\beta b+\\gamma c \\end{aligned} $$\n令：\n$$ \\begin{aligned} \\alpha \u0026amp;= 1-\\beta-\\gamma \\end{aligned} $$\n当 $\\alpha$、$\\beta$、$\\gamma$ 均大于 0 小于 1 时，$p$ 位于三角形内部 当 $\\alpha$、$\\beta$、$\\gamma$ 中有一个分量等于 0 时，$p$ 在三角形边上 当 $\\alpha$、$\\beta$、$\\gamma$ 中有两个变量等于 0 时，$p$ 在某个顶点上 以坐标形式表示：\n$$ p = (\\alpha, \\beta, \\gamma) $$\n重心坐标的计算 面积法 $$ \\begin{aligned} \\alpha = \\frac{A_a}{A_a+A_b+A_c} \\cr \\beta = \\frac{A_b}{A_a+A_b+A_c} \\cr \\gamma = \\frac{A_c}{A_a+A_b+A_c} \\end{aligned} $$\n求面积可以使用叉乘：\n$$ \\alpha = \\frac{A_a}{A} = \\frac{\\vert (c-b) \\times (c-p)\\vert}{\\vert (a-b) \\times (a-c)\\vert} $$\n但是求出来的 $\\alpha$ 失去了方向性。我们可以通过点乘一个法线来解决这个问题：\n$$ \\alpha = \\frac{((c-b) \\times (p-b))\\cdot n}{((b-a) \\times (c-a))\\cdot n} $$\n这个等式之所以成立的关键是两个向量 $a$、$b$ 的点乘表达式为： $$a\\cdot b = \\vert a\\vert\\vert b\\vert\\cos\\theta$$ 当它们相互垂直的时候，$\\cos\\theta = 1$，那么上面的表示式实际上可以被表达为： $$ \\alpha = \\frac{\\vert(c-b) \\times (p-b)\\vert \\vert n\\vert}{\\vert(b-a) \\times (c-a)\\vert \\vert n\\vert} = \\frac{\\vert(c-b) \\times (p-b)\\vert}{\\vert(b-a) \\times (c-a)\\vert} $$ 这个结果和之前的推导一样。\n同时我们从叉乘的定义中得到 $n = ab \\times ac$。\n最终，我们得到了最终结果：\n$$ \\begin{aligned} \\alpha \u0026amp;= \\frac{n_a \\cdot n}{n\\cdot n}\\cr \\beta \u0026amp;= \\frac{n_b \\cdot n}{n\\cdot n}\\cr \\gamma \u0026amp;= \\frac{n_c \\cdot n}{n\\cdot n} \\end{aligned} $$\n其中：\n$$ \\begin{aligned} n_a \u0026amp;= (c-b) \\times (p-b)\\cr n_b \u0026amp;= (a-c) \\times (p-c)\\cr n_c \u0026amp;= (b-a) \\times (p-a) \\end{aligned} $$\n代数法 把上一小节的公式，写成这样的形式：\n$$ \\beta(b-a)+\\gamma(c-a)+(a-p)= 0 $$\n分别带入 x 和 y，得到两个方程，求两个未知数：\n$$ \\begin{aligned} (x_b - x_a)\\beta+(x_c - x_a)\\gamma+(x_a - x_p) \u0026amp;= 0\\cr (y_b - y_a)\\beta+(y_c - y_a)\\gamma+(y_a - y_p) \u0026amp;= 0 \\end{aligned} $$\n最终的结果:\n$$ \\begin{aligned} \\gamma \u0026amp;= \\frac{(y_a-y_b)x_p+(x_b-x_a)y_p+x_a y_b-x_b x_a}{(y_a-y_b)x_c+(x_a-x_b)y_c+x_a y_b-x_b x_a}\\cr \\beta \u0026amp;= \\frac{(y_a-y_c)x_p+(x_c-x_a)y_p+x_a y_c-x_c x_a}{(y_a-y_c)x_b+(x_c-x_a)y_b+x_a y_c-x_c x_a}\\cr \\alpha \u0026amp;= 1-\\gamma-\\beta \\end{aligned} $$\n上面是标准的求法，还有一种捷径。\n把上面两个方程变成矩阵形式：\n$$ \\begin{aligned} \\begin{bmatrix} x_b - x_a \u0026amp; x_c - x_a \u0026amp; x_a - x_p \\cr \\end{bmatrix} \\begin{bmatrix} \\beta \\cr \\gamma \\cr 1 \\end{bmatrix} \u0026amp;= 0\\cr \\begin{bmatrix} y_b - y_a \u0026amp; y_c - y_a \u0026amp; y_a - y_p\\cr \\end{bmatrix} \\begin{bmatrix} \\beta \\cr \\gamma \\cr 1 \\end{bmatrix} \u0026amp;= 0 \\end{aligned} $$\n说明向量 $\\begin{bmatrix}x_b - x_a \u0026amp; x_c - x_a \u0026amp; x_a - x_p \\end{bmatrix}$ 垂直于向量 $\\begin{bmatrix}\\beta \u0026amp;\\gamma \u0026amp; 1\\end{bmatrix}$，向量 $\\begin{bmatrix}y_b - y_a \u0026amp; y_c - y_a \u0026amp; y_a - y_p \\end{bmatrix}$ 垂直于向量 $\\begin{bmatrix}\\beta \u0026amp;\\gamma \u0026amp; 1\\end{bmatrix}$。\n得到：\n$$ \\begin{bmatrix} x_b - x_a \\cr x_c - x_a \\cr x_a - x_p \\end{bmatrix}\\times \\begin{bmatrix} y_b - y_a \\cr y_c - y_a \\cr y_a - y_p \\end{bmatrix}= \\begin{bmatrix} k\\beta \\cr k\\gamma \\cr k \\end{bmatrix} $$\n这是最快的重心计算法，它只使用了一个叉乘就解决了问题。\n重心坐标代码实现 根据上面推导的公式，最终，代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 for (int y = min.y; y \u0026lt;= max.y; y++) { for (int x = min.x; x \u0026lt;= max.x; x++) { Vector3i vx(p1.x - p0.x, p2.x - p0.x, p0.x - x); Vector3i vy(p1.y - p0.y, p2.y - p0.y, p0.y - y); Vector3i u = vx.Cross(vy); if (std::abs(u.z) \u0026lt; 1) { continue; } Vector3f barycentric(1.f - (u.x + u.y) / (float)u.z, u.x / (float)u.z, u.y / (float)u.z); if (barycentric.x \u0026gt; 0 \u0026amp;\u0026amp; barycentric.x \u0026lt; 1 \u0026amp;\u0026amp; barycentric.y \u0026gt; 0 \u0026amp;\u0026amp; barycentric.y \u0026lt; 1 \u0026amp;\u0026amp; barycentric.z \u0026gt; 0 \u0026amp;\u0026amp; barycentric.z \u0026lt; 1) { PutPixel(Vector2i(x, y), color); } } } 参考资料 Fundamentals of Computer Graphics 三角形重心坐标 ","date":"2023-12-12T16:42:50+08:00","permalink":"https://nonlinearthink.github.io/p/%E7%BC%96%E5%86%99%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8%E5%9B%9B%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/","title":"编写光栅化渲染器（四）绘制三角形"},{"content":"DDA Line DDA(Digital Differential Analyzer) 正如其名，就是最直观的直线画法，原始的算法的描述如下：\n假设存在屏幕空间上的两个点 $(x1, y1)$ 和 $(x2, y2)$\n计算 $dx=x2-x1$，$dy=y2-y1$。 计算斜率 $k=\\frac{dy}{dx}$。 x 从 x1 出发，每次向 x2 移动一个单位，计算 $y=y1+k(x–x1)$。 1 2 3 4 5 6 7 8 9 10 11 12 void DDA(int x0, int y0, int x1, int y1) { // 计算 dx \u0026amp; dy \u0026amp; k int dx = x1 - x0; int dy = y1 - y0; float k = dy / dx; // 循环绘制每一个像素 for (int x = x1; x \u0026lt;= x2; x++) { putpixel(x, round(y1 + k * (x - x1)), RED); } } 原始算法看起来很可靠，但是仍然有一些可以优化的地方，因为直线是线性且均匀的，所以假如提前计算好了每一次循环的增量，就可以避免 y1 + k * (x - x1) 中的浮点数乘法。\n优化过后的 DDA 算法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void DDA(int x0, int y0, int x1, int y1) { // 计算 dx \u0026amp; dy int dx = x1 - x0; int dy = y1 - y0; // 计算需要计算多少步像素 int steps = abs(dx) \u0026gt; abs(dy) ? abs(dx) : abs(dy); // 计算 x \u0026amp; y 每一步的增量 float xinc = dx / (float)steps; float yinc = dy / (float)steps; // 循环绘制每一个像素 float x = x0; float y = y0; for (int i = 0; i \u0026lt;= steps; i++) { putpixel(round(x), round(y), RED); x += xinc; y += yinc; } } Bresenham\u0026rsquo;s Line 从上面 DDA 的优化案例可以看出，避免浮点数操作就是优化画线算法的关键。\nBresenham's Line 相比 DDA 不仅有更少的浮点数运算，而且没有浮点数和整数的类型转换。\n算法的核心思想如下：\n在 $(x_k, y_k)$ 的位置时候，可能走向 $(x_k+1, y_k)$ 也可能走向 $(x_k+1, y_k+1)$，显然，斜线的交点更加靠近谁，就往哪个方向走。\n斜率:\n$$ k = \\frac{\\Delta y}{\\Delta x} $$\n对于每一次循环，执行：\n$$ x_{i+1} = x_i + 1\\ e_{i+1} = e_i + k\\ $$\n同时，始终保证 $0 \u0026lt; e \u0026lt; 1$：\n$$ e_{i+1} = e_{i+1} - 1, e_{i+1} \u0026gt; 1 $$\n最后，得出这个点的 y：\n$$ y_{i+1} = \\begin{cases} y_i+1 \u0026amp;\\text{if } e_{i+1} \\gt 0.5\\cr y_i \u0026amp;\\text{if } e_{i+1} \\le 0.5\\cr \\end{cases} $$\n上面的算法是 Bresenham's Line 的基本思想，还需要进一步优化，减少浮点数运算。\n可能产生浮点数的地方是 $k = \\frac{\\Delta y}{\\Delta x}$ 和 $e_{i+1} \\gt 0.5$，所以我们最后再把上面所有的过程乘以 $2\\Delta x$。\n最终，我们的代码如下，其中 $\\Delta x = x_2 - x_1, \\Delta y = y_2 - y_1$：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void bresenham(int x1, int y1, int x2, int y2) { int m = 2 * (y2 - y1); int slope_error = m - (x2 - x1); for (int x = x1, y = y1; x \u0026lt;= x2; x++) { putpixel(x, y, RED); slope_error += m; if (slope_error \u0026gt;= 0) { y++; slope_error -= 2 * (x2 - x1); } } } 最后的代码虽然看起来简洁，但是因为优化过，第一次接触容易摸不着头脑。\n其他算法 还有一种叫 Mid-Point Line ，因为它即没有 DDA 简单直接，也没有 Bresenham 效率高，这里就不介绍了。\n","date":"2023-12-08T23:12:03+08:00","permalink":"https://nonlinearthink.github.io/p/%E7%BC%96%E5%86%99%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B8%89%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF/","title":"编写光栅化渲染器（三）绘制直线"},{"content":"我们的第一个目标就是创建一个窗口，创建窗口有很多库都能做，如果你不想要用任何第三方库也不需要跨平台，用 Win32 API 就可以做，不过微软的匈牙利命名法实在是抽象，要有心里准备。\nSDL 库简介 SDL (Simple DirectMedia Layer) 是一个开源、跨平台、轻量级的多媒体层，作者目前在 Valve 任职，也就是大家最喜欢的 Steam，我们基本上只需要用到 SDL_Window 和 SDL_Surface 就可以。\n这里默认大家拥有 C++ 和 CMake 基础，不介绍怎么安装这个库了，直接开始。\n创建 Window 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #define SDL_MAIN_HANDLED #include \u0026#34;SDL.h\u0026#34; int main(int argc, char* argv[]) { // 定义窗口大小 const int width = 640; const int height = 480; // SDL 初始化 if (SDL_Init(SDL_INIT_EVENTS) \u0026lt; 0) { SDL_Log(\u0026#34;SDL init failed\u0026#34;); return 1; } // 创建 SDL 窗口 SDL_Window* window = SDL_CreateWindow( \u0026#34;SoftRenderer\u0026#34;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, wWidth, wHeight, SDL_WINDOW_SHOWN); if (!window) { SDL_Log(\u0026#34;create window failed\u0026#34;); SDL_Quit(); return 1; } // 一直循环，直到触发了 SDL_QUIT 事件（窗口被关闭） bool isQuit = false; SDL_Event event; while (!isQuit) { while (SDL_PollEvent(\u0026amp;event)) { if (event.type == SDL_QUIT) { isQuit = true; } } } // 释放资源 SDL_DestroyWindow(window); SDL_Quit(); return 0; } 这是一个最简单的 SDL 创建窗口的程序。\nSDL CPU 渲染：获取和更改 Surface 从 Window 可以获取一个 Surface，它和 Window 的大小相同高，并且它里面有一个 pixels 指针，可以访问每一个像素的数据。\n1 2 3 4 5 6 7 8 9 10 while (!isQuit) { ... // 获取窗口的 Surface SDL_Surface* surface = SDL_GetWindowSurface(window); // 像素数据在 surface-\u0026gt;pixels 中 // 更改 Surface 颜色 SDL_FillRect(surface, NULL, SDL_MapRGB(surface-\u0026gt;format, 0, 255, 0)); // 更新窗口的 Surface SDL_UpdateWindowSurface(window); } 从 Window 获取的 Surface 的格式可能并不是我们想要的。\n默认的 Window Surface 每一个像素是 32 位，但是实际上用的只有 24 位，我们就需要给每个像素写入这样：\n1 0x00FF0000 // RGB 红色 因为计算机中存储非 2 的幂次大小的数据会有性能问题，所以 SDL 这里数据是 32 位的，实际使用却是 24 位，头两位是无意义的。\n我们可能更希望使用 RGBA 格式的数据，RGBA 刚好就是 32 位：\n1 0xFF0000FF // RGBA 红色 这个时候我建议自己额外建一个 Surface，渲染完之后再更新给 Window 的 Surface。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 while (!isQuit) { ... // 创建 RGBA 的 render surface SDL_Surface* render_surface = SDL_CreateRGBSurfaceWithFormat( 0, width, height, 32, SDL_PIXELFORMAT_RGBA8888); // 渲染 render surface SDL_FillRect(render_surface, NULL, SDL_MapRGBA(surface-\u0026gt;format, 0, 255, 0, 255)); // 获取 window surface SDL_Surface* window_surface = SDL_GetWindowSurface(window); // 更新 render surface 到 window surface SDL_BlitSurface(render_surface, NULL, window_surface, NULL); // 更新 window surface 到 screen SDL_UpdateWindowSurface(window); // 释放 render surface SDL_FreeSurface(render_surface); } SDL GPU 渲染：Renderer 和 Texture 这一小节为补充内容，如果目标是做 CPU 的软渲染器，不需要了解。\n在 SDL 中，有两种方法可以去做渲染图形，一种是通过 SDL_Surface，另外一种是通过 SDL_Texture。\n区别在于 SDL_Surface 是在 CPU 中，而 SDL_Texture 在 GPU 中。\n使用 GPU 渲染必须要先创建 Renderer：\n1 2 3 4 5 6 SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, 0); if (!renderer) { SDL_Log(\u0026#34;create renderer failed.\u0026#34;); SDL_Quit(); return 1; } 还需要创建一张 Texture，我们不会直接绘制 Renderer，而是绘制在 Texture 上，在计算机图形学中，这种图像绘制在纹理上而不是屏幕上的技术叫做 Render Target Texture。\n1 2 3 4 5 6 7 SDL_Texture* rtt = SDL_CreateTexture(app-\u0026gt;_renderer, SDL_PIXELFORMAT_RGBA8888, 0, width, height); if (!rtt) { SDL_Log(\u0026#34;create renderer target texture failed.\u0026#34;); SDL_Quit(); return 1; } 每帧调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 while (!isQuit) { ... // 设置默认背景颜色 SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); // 清空屏幕 SDL_RenderClear(renderer); // 创建一个 Surface 来更改像素 SDL_Surface* surface = SDL_CreateRGBSurfaceWithFormat( 0, width, height, 32, SDL_PIXELFORMAT_RGBA8888); // 渲染，更改像素 SDL_FillRect(surface, NULL, SDL_MapRGBA(surface-\u0026gt;format, 0, 255, 0, 255)); // 更新 Surface 到 Texture 上 SDL_UpdateTexture(rtt, NULL, surface-\u0026gt;pixels, surface-\u0026gt;pitch); SDL_FreeSurface(surface); // 覆盖 Texture 到 Renderer 里面 SDL_RenderCopy(renderer, rtt, NULL, NULL); // 发送数据到 GPU SDL_RenderPresent(renderer); } 改写 C 风格的代码 SDL 是一个 C 的库，而不是 C++，这样风格的代码在 C++ 中是不安全和不便利的。所以我们需要做一些改造。\n使用智能指针 SDL 中有很多成对的比如 SDL_CreateWindow 和 SDL_DestroyWindow 函数。如果我们能自动释放就好了，可以用智能指针来解决这个问题。\n尝试重写智能指针的 Deleter：\n1 2 3 4 struct SDL_Window_Deleter { void operator()(SDL_Window* window) const { SDL_DestroyWindow(window); } }; using Unique_SDL_Window_Ptr = std::unique_ptr\u0026lt;SDL_Window, SDL_Window_Deleter\u0026gt;; 使用起来也格外方便：\n1 2 3 Unique_SDL_Window_Ptr window = Unique_SDL_Window_Ptr(SDL_CreateWindow( \u0026#34;SoftRenderer\u0026#34;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, width, height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE)); 尝试自己实现 SDL_Surface 的 Deleter\n使用 Class 封装 之前的 SDL 代码大致可以分为两个部分，一个是在 while 循环之前的初始化阶段，还有一个是在 while 循环内部的每帧执行阶段。\n1 2 3 4 5 6 7 8 RenderApplication app(width, height); if (!app-\u0026gt;InitApplication()) { return 1; } while (app-\u0026gt;running) { app-\u0026gt;Tick(); } 最终，RenderApplication 长这个样子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class RenderApplication { public: int width, height; bool running; RenderApplication(int _width, int _height) : width(_width), height(_height), running(true) { renderer_ = std::make_unique\u0026lt;SoftRenderer::Renderer\u0026gt;( width, height, SoftRenderer::Color::Black()); } ~RenderApplication() { // 这里不需要释放，因为 window 会释放它 window_surface_ = nullptr; SDL_Quit(); } bool InitApplication() { if (SDL_Init(SDL_INIT_EVENTS) \u0026lt; 0) { SDL_Log(\u0026#34;SDL init failed\u0026#34;); return false; } window_ = Unique_SDL_Window_Ptr(SDL_CreateWindow( \u0026#34;SoftRenderer\u0026#34;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, width, height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE)); if (!window_) { SDL_Log(\u0026#34;create window failed.\u0026#34;); SDL_Quit(); return false; } window_surface_ = SDL_GetWindowSurface(window_.get()); event_ = std::make_unique\u0026lt;SDL_Event\u0026gt;(); return true; } void Tick() { while (SDL_PollEvent(event_.get())) { if (event_-\u0026gt;type == SDL_QUIT) { running = false; return; } } // 渲染前的准备 Unique_SDL_Surface_Ptr render_surface(SDL_CreateRGBSurfaceWithFormat( 0, width, height, 32, SDL_PIXELFORMAT_RGBA8888)); renderer_-\u0026gt;PrepareRender((Uint32*)render_surface-\u0026gt;pixels); // 清空屏幕 renderer_-\u0026gt;Clear(); // 自定义渲染函数 render(); // 更新 renderer surface 到 window surface SDL_BlitSurface(render_surface.get(), NULL, window_surface_, NULL); // 更新 window surface 到 screen SDL_UpdateWindowSurface(window_.get()); // 保持稳定的帧数 SDL_Delay(1000 / 60); } virtual void render() {} protected: std::unique_ptr\u0026lt;SoftRenderer::Renderer\u0026gt; renderer_; Unique_SDL_Window_Ptr window_; SDL_Surface* window_surface_; std::unique_ptr\u0026lt;SDL_Event\u0026gt; event_; }; ","date":"2023-12-05T12:08:06+08:00","permalink":"https://nonlinearthink.github.io/p/%E7%BC%96%E5%86%99%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8%E4%BA%8Csdl%E5%BA%93%E7%AE%80%E4%BB%8B/","title":"编写光栅化渲染器（二）SDL库简介"},{"content":"光栅化 VS 光线追踪 对图形学稍微有了解的小伙伴应该知道，现在的实时渲染领域用的主要都是 Rasterization(光栅化)，而不是 Ray Tracing(光线追踪)，主要原因是实时渲染需要保证帧数稳定在 30 帧以上，而 Ray Tracing 需要非常庞大的计算量，完全不是多少 ms 之内能计算完的。\n等完成 编写光栅化渲染器 这个系列之后有一个关于 Ray Tracing 的新系列。\n屏幕由一个一个像素构成，每一个像素都可以被认为是一个小网格（实际上从物理结构上来讲并不是完全正方形的）\n那么如果要渲染一个场景，只需要把每一个网格填上颜色就可以了，光栅化实际上就是在聊怎么填颜色这件事情。比如你需要对场景里的物体进行排序，离相机近的物体表面颜色就是你想要绘制的图形的颜色。\n光线追踪技术则是基于物理，从一个像素点出发，经过多次反射，得到最终颜色，但是一个像素一条射线远远不够，因为这样误差会很大，往往一个像素需要数百条射线的结果求平均。\n光线追踪的本质就是对场景不断进行采样以降低噪点，最终得到最接近真实的图像。\n从时间复杂度来说，光栅化无疑比光线追踪来得更加好，但是因为缺少严谨的物理模型，光栅化的效果比光线追踪差很多，所以在对性能要求不高，但是对效果要求高的离线渲染中，光线追踪被普遍运用。\n截至文章编写日期，已经有游戏比如 赛博朋克2077 2.0 运用了 Path Tracing 技术，也叫 Monte Calo Ray Tracing，比传统的 Whitted Style Ray Tracing 性能更加好，效果也更棒。\n光栅化程序开发流程 创建一个窗口，并绘制直线，三角形，带有顶点数据的物体。 施工中\u0026hellip;\nReference Fundamentals of Computer Graphics\n","date":"2023-12-02T14:15:23+08:00","permalink":"https://nonlinearthink.github.io/p/%E7%BC%96%E5%86%99%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B8%80%E6%A6%82%E8%BF%B0/","title":"编写光栅化渲染器（一）概述"},{"content":"我最近想要做一些 C++ 的项目，在正式开始之前，我需要先搭建环境，也是大概花了一个晚上，简单了解了一下现在 C++ 项目都是怎么构建的。\n目前比较主流的两种包管理器：conan 和 vcpkg，我都试用了一下，个人感觉 vcpkg 的兼容性更好一些，应该可以帮我避不少坑，所以最终选择了使用 Vcpkg+CMake+VSCode 去构建我的编程环境。\n我参考了 VsCode+Vcpkg+MSVC——C++开发环境配置 这篇文章，但是他有些地方的坑没讲明白，我重新整理和归纳一下。\n准备 C++ 编译器 Windows: Visual C++(目前使用)、MinGW macOS: Clang、GCC CMake Windows: Download | CMake macOS: brew install\u0026hellip; VSCode CMake Tools C/C++ vcpkg 安装 官方中文文档：vcpkg/README_zh_CN.md at master · microsoft/vcpkg · GitHub\n阅读快速开始的部分，按照指令一条条做。\nGit Clone 不下来？ 运用科技手段 导入项目地址到 Gitee Github 镜像下载网站 运行 bootstrap-vcpkg.bat 或者 bootstrap-vcpkg.sh 卡住并且报错？ 运用科技手段 去这个页面下载 vcpkg.exe: Releases · microsoft/vcpkg-tool (github.com)，然后拷贝到 Clone 下来的 Git 根目录 macOS 应该是下载 vcpkg-macos，我没试过\n配置环境变量 这一步网上很多人没讲，环境变量可以让后面路径的配置和维护方便很多。\n配置一个叫 VCPKG_ROOT 的变量，待会要用，地址就是刚才 Clone 的那个 Git 根目录。\n配置完之后检查一下：\n1 2 3 4 # powershell $env:VCPKG_ROOT # bash echo $VCPKG_ROOT 安装依赖 安装一个库：\n1 .\\vcpkg.exe install fmt:x86-windows 安装依赖一般就是 [库名]:[编译目标]。\n这里补充一个重点，一定要选择和自己的编译器一样的编译目标，我一开始用了 Visual C++ 的 64 位编译器，结果后面编译的时候一直出问题，因为 x86-windows 是 32 位的。\n添加依赖到 CMake 切回到 CMake 项目中。\n在 CMakeLists.txt 中加入两条新的命令，find_package 和 target_link_libraries，编辑完之后大概是这个样子的：\n1 2 3 4 5 6 7 8 9 10 project(TestVcpkg VERSION 0.1.0) ...... add_executable(TestVcpkg main.cpp) ...... find_package(fmt CONFIG REQUIRED) target_link_libraries(TestVcpkg PRIVATE fmt::fmt) target_link_libraries 必须在 find_package 和 add_executable 后面。\n测试程序 引入并使用一下 fmt 库试试。\n1 2 3 4 5 6 #include \u0026#34;fmt/format.h\u0026#34; int main(int, char **) { fmt::print(\u0026#34;Hello, world!\\n\u0026#34;); } 编译 创建一个 CMake 项目，不知道怎么创建，可以参考后面的 VSCode 部分。\n构建项目：\n1 2 3 4 # powershell cmake -B . -S build -DCMAKE_TOOLCHAIN_FILE=$env:VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake # bash cmake -B . -S build -DCMAKE_TOOLCHAIN_FILE=$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake -B 后面跟着的是 CMakeLists.txt 的位置 -S 后面跟着的是编译到那个位置，一般都是项目目录下新建一个 build 目录 最后跟着的是配置 CMAKE_TOOLCHAIN_FILE，需要用到之前配置的环境变量 VCPKG_ROOT。 编译项目：\n1 cmake --build build 运行 找到 build/Debug 下的可执行文件，运行一下就行了。\n清单模式 不使用这个也能用，但是强烈推荐使用\n简单来说，就是依赖配置文件，会在你运行 CMake 的时候自动帮你安装依赖。\n务必要看一下这个：\n使用清单模式入门 | Microsoft Learn\n清单模式 | Microsoft Learn\nVSCode 配置 VSCode 的主要目的是自动化上面的一些命令。\n建立 Cmake 项目 VSCode 打开一个空目录，使用 Ctrl+Shift+P|⌘+⇧+P 打开 Command Palette，找到并运行 CMake: Quick Start。\nvcpkg 加入 CMake 自动化编译流程 VSCode 会在你更新 CMakeLists.txt 的时候帮你自动运行 CMake 命令，为了在运行的时候加入 CMAKE_TOOLCHAIN_FILE 的设置，你需要编辑 settings.json：\n1 2 3 4 5 6 { \u0026#34;cmake.configureSettings\u0026#34;: { \u0026#34;CMAKE_TOOLCHAIN_FILE\u0026#34;: \u0026#34;${env:VCPKG_ROOT}/scripts/buildsystems/vcpkg.cmake\u0026#34;, \u0026#34;VCPKG_TARGET_TRIPLET\u0026#34;: \u0026#34;x86-windows\u0026#34; }, } 这样配置完之后相当于在 cmake 执行的时候加入了：\n1 -DCMAKE_TOOLCHAIN_FILE=$env:VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake -DVCPKG_TARGET_TRIPLET=x86-windows 这里用到的 ${env:VCPKG_ROOT} 就是上面提到的环境变量，而编译目标，取决于你使用的编译器。\n可以在 .vscode 文件夹下新建一个 settings.json，这样可以给每个项目自定义使用 x64-windows 还是 x86-windows\n到这一步为止，保存刷新一下 CMakeLists.txt，VSCode 应该没有报错，并且成功帮你编译好了 CMake，如果有问题，去检查一下上面的流程，特别是 vcpkg 官方文档的内容我没怎么提，仔细检查一下。\n识别和跳转 #include 头文件 默认情况下，代码编辑器会有一个报错，#include 找不到 vcpkg 安装的库，但是执行 Debug 或者 Run 任务，都没有任何问题。\n这是因为 VSCode 没有在 vcpkg 的目录中找头文件。\n再次运行 Ctrl+Shift+P|⌘+⇧+P 打开 Command Palette，找到并使用 C/C++: Edit Configurations(JSON)，它会创建一个 .vscode 文件夹，里面有一个 c_cpp_properties.json 文件，编辑其中的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;configurations\u0026#34;: [ { ...... \u0026#34;includePath\u0026#34;: [ \u0026#34;${workspaceFolder}/**\u0026#34;, \u0026#34;${env:VCPKG_ROOT}/installed/x64-windows/include\u0026#34;, \u0026#34;${env:VCPKG_ROOT}/installed/x86-windows/include\u0026#34; ], ...... } ], ...... } 很多教程会在这里写上一个 ${vcpkgRoot}/x64-windows/include，其实这个 ${vcpkgRoot} 就是我们上面配置的 ${env:VCPKG_ROOT} 加上 installed。\n","date":"2023-04-15T02:48:00+08:00","permalink":"https://nonlinearthink.github.io/p/%E4%BD%BF%E7%94%A8-vcpkg-cmake-vscode-%E7%BC%96%E5%86%99%E4%BD%A0%E7%9A%84-c-%E9%A1%B9%E7%9B%AE/","title":"使用 vcpkg+CMake+VSCode 编写你的 C++ 项目"},{"content":"DDNS(Dynamic Domain Name Server)，它的作用是将用户的动态IP绑定到一个域名上去。\n这样就算你的服务器IP发生了变化，用户仍然可以使用你的域名找到你的服务器。\n阿里云提供了一套API，可以让你用编程的方式实现 DDNS，但是需要你的域名是在阿里云上申请的。\n感谢我的室友借用给我测试用的域名。\n一些可能用到的库 1 2 3 pip install aliyun-python-sdk-core pip install aliyun-python-sdk-alidns pip install pyyaml 获取和缓存 IP 地址 先写一个简单的工具类，可以获取当前电脑的 公网IP 地址，有很多提供这类服务的网站，本例程采用www.3322.org/dyndns/getip。\n获取 IP 之后最好再把它缓存在一个文件中。\n之所以需要缓存是因为阿里云更新两条一样的IP时会报错，我们可以提前缓存，然后下次调用更新服务之前借用缓存的内容，判断当前的 IP 是否无变化。\n定义 IPManager 类 定义一个 IPManager 类，可以获取本机的 公网IP 地址，并使用文件进行缓存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from urllib.request import urlopen import logging class IPManager: def __init__(self, file_cache=\u0026#34;.ipbuffer\u0026#34;): self.ip = \u0026#34;\u0026#34; self.file_cache = file_cache def get_current_ip(self): # 获取当前的 IP with urlopen(\u0026#39;http://www.3322.org/dyndns/getip\u0026#39;) as response: self.ip = str(response.read(), encoding=\u0026#39;utf-8\u0026#39;).replace(\u0026#34;\\n\u0026#34;, \u0026#34;\u0026#34;) logging.info(\u0026#34;current ip: \u0026#34; + self.ip) return self.ip def sync_cache(self): # 同步当前的 IP 到缓存 with open(self.file_cache, \u0026#34;w\u0026#34;) as f: f.write(self.ip) logging.info(\u0026#34;sync cache ip: \u0026#34; + self.ip) def get_cache(self): # 获取缓存的内容 with open(self.file_cache, \u0026#34;r\u0026#34;) as f: old_ip = f.read() logging.info(\u0026#34;get cache ip: \u0026#34; + self.ip) return old_ip 程序默认使用 .ipbuffer 文件存储 IP，我觉得我们还需要先创建这个文件，不然运行的时候可能会报错。\n可以使用下面的函数检查和创建一个文件，支持递归创建:\n1 2 3 4 5 6 7 8 9 10 11 12 import os def check_file(filename): # 获取父文件夹 dirname = os.path.dirname(filename) if not os.path.exists(dirname) and dirname != \u0026#34;\u0026#34;: # 递归创建父文件夹 os.makedirs(dirname) # 创建文件 with open(filename, \u0026#34;w\u0026#34;) as f: f.write(\u0026#34;\u0026#34;) IPManager 的简单使用 1 2 3 4 5 6 7 8 9 10 def main(): # 创建一个 IPManager ip_manager = IPManager() # 获取当前的 IP current_ip = ip_manager.get_current_ip() # 如果 IP 已经缓存就返回 if ip_manager.get_cache() == current_ip: return # 更新 IP 缓存 ip_manager.sync_cache() 这个程序可以 获取IP 并且在 IP无缓存 或者 IP更新 的时候更新缓存。\n获取 accessKeyId 和 accessKeySecret 云账号登录RAM控制台。 在左侧导航栏的人员管理菜单下，单击用户。 在用户登录名称/显示名称列表下，单击目标RAM用户名称。 在用户AccessKey区域下，单击创建新的AccessKey。 摘抄自 阿里云文档\n创建连接阿里云的客户端 1 2 3 4 5 6 7 8 from aliyunsdkcore.client import AcsClient profile = { \u0026#34;accessKeyId\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;accessKeySecret\u0026#34;: \u0026#34;xxx\u0026#34;, \u0026#34;regionId\u0026#34;: \u0026#34;cn-hangzhou\u0026#34; } client = AcsClient(profile[\u0026#34;accessKeyId\u0026#34;], profile[\u0026#34;accessKeySecret\u0026#34;], profile[\u0026#34;regionId\u0026#34;]) 把上一步的 accessKeyId、accessKeySecret 填进去。\n在 regionId 填写你的区域号，关于 regionId 的说明，可以见 阿里云官方文档。\n我们需要借助 client.do_action_with_exception 这个函数来发送请求到阿里云。\n域名解析记录查询 之所以需要加一步域名解析记录查询是为了校验我们的域名是否已经被其他的 IP 绑定了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from aliyunsdkalidns.request.v20150109.DescribeDomainRecordsRequest import DescribeDomainRecordsRequest import json import logging def describe_domain_records(client, record_type, subdomain): logging.info(\u0026#34;域名解析记录查询\u0026#34;) request = DescribeDomainRecordsRequest() request.set_accept_format(\u0026#39;json\u0026#39;) request.set_Type(record_type) request.set_DomainName(subdomain) response = client.do_action_with_exception(request) response = str(response, encoding=\u0026#39;utf-8\u0026#39;) result = json.loads(response) logging.debug(result) return result client 是上一步创建的客户端。\nrecord_type 比较复杂，简单来说是 DNS域名解析 的解析类型。我们这里使用 A记录 就好了。\n{% note info %}\n常见的 DNS解析类型\nA: 将主机名(或域名)指向一个 IPv4 地址\nAAAA: 将主机名(或域名)指向一个 IPv6 地址\nCNAME: 将域名指向另一个域名\n{% endnote %}\nsubdomain 填你的域名就好了。\n1 2 # 调用举例 describe_domain_records(client, \u0026#34;A\u0026#34;, \u0026#34;tuenity.xyz\u0026#34;) 添加域名解析记录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from aliyunsdkalidns.request.v20150109.AddDomainRecordRequest import AddDomainRecordRequest import logging import json def add_record(client, priority, ttl, record_type, value, rr, domain_name): logging.info(\u0026#34;添加域名解析记录\u0026#34;) request = AddDomainRecordRequest() request.set_accept_format(\u0026#39;json\u0026#39;) request.set_Priority(priority) request.set_TTL(ttl) request.set_Value(value) request.set_Type(record_type) request.set_RR(rr) request.set_DomainName(domain_name) response = client.do_action_with_exception(request) response = str(response, encoding=\u0026#39;utf-8\u0026#39;) result = json.loads(response) logging.debug(result) return result priority 告诉域名解析服务，按照 priority 从小到大的顺序对记录搜索，搜索到匹配的记录后，就停止搜索 priority 值更大的记录，对于拥有相同 priority 的记录将通过 weight 再次选择 。\n虽然阿里云并不提供 weight 的设置接口，但是你要知道它是个什么东西。\n对于拥有相同 priority 的多条记录，weight 给出了选择某条记录的几率，值越大，被选中的概率就越大，合理的取值范围为 0-65535。\nttl( Time to live )，当用户在访问一个域名的时候，并不是每次都需要去解析一遍的，DNS服务器会在用户当地的递归DNS服务器上缓存一次，在 ttl 的时间长度内失效。一般设置 \u0026ldquo;600\u0026rdquo;。\nrecord_type 同上一步。\nvalue 就是你的 IP地址。\nrr，阿里云的 rr 是主机头的意思，一般设置 \u0026ldquo;www\u0026rdquo;。\ndomain_name 就是你的域名。\n更新域名解析记录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from aliyunsdkalidns.request.v20150109.UpdateDomainRecordRequest import UpdateDomainRecordRequest import logging import json def update_record(client, priority, ttl, record_type, value, rr, record_id): logging.info(\u0026#34;更新域名解析记录\u0026#34;) request = UpdateDomainRecordRequest() request.set_accept_format(\u0026#39;json\u0026#39;) request.set_Priority(priority) request.set_TTL(ttl) request.set_Value(value) request.set_Type(record_type) request.set_RR(rr) request.set_RecordId(record_id) response = client.do_action_with_exception(request) response = str(response, encoding=\u0026#39;utf-8\u0026#39;) logging.debug(response) return response 和上一步的函数接口几乎一摸一样，不过多解释了。\n需要注意，不一样的是 record_id。这个需要 describe_domain_records 函数的返回值。\n1 des_result = describe_domain_records(client, \u0026#34;A\u0026#34;, \u0026#34;tuenity.xyz\u0026#34;) 使用 des_result[\u0026quot;TotalCount\u0026quot;] 就可以查处现在有多少条记录绑定在这个域名上了。\n如果没有，我们就需要调用 add_record ，否则就调用 update_record。\nrecord_id 可以通过 des_result[\u0026quot;DomainRecords\u0026quot;][\u0026quot;Record\u0026quot;][0][\u0026quot;RecordId\u0026quot;] 获取。\n改造、封装建议 使用 yaml 来作为配置文件 使用 python 自带的日志 logging 把查询、更新、添加域名解析记录封装成一个类 获取完整的代码 Github 项目地址\n","date":"2020-10-25T12:08:06+08:00","permalink":"https://nonlinearthink.github.io/p/python-%E5%AE%9E%E7%8E%B0%E9%98%BF%E9%87%8C%E4%BA%91-ddns-%E5%8A%A8%E6%80%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90/","title":"Python 实现阿里云 DDNS 动态域名解析"},{"content":"Cordova 安装 使用 npm 安装 cordova 命令行:\n1 npm install -g cordova 创建 Vue 项目:\n1 vue create cordova-test 找了一圈 Vue 的 Cordova 插件，个人觉得最好用的是这个: vue-cli-plugin-cordova-simple。这位老哥写得这么好，都没人帮他宣传。\n1 vue add vue-cli-plugin-cordova-simple 新建 vue.config.js 文件:\n1 2 3 module.exports = { publicPath: \u0026#34;./\u0026#34;, }; 另外，router 不要使用 history 模式，使用 hash 模式。\niOS 环境配置 iOS 环境只能在 Mac 中配置。\n先用 cordova 命令行为项目添加 iOS 打包工具。\n1 cordova add ios 在 App Store 安装 Xcode\n安装 ios-deploy\n使用 npm 安装:\n1 npm install -g ios-deploy 安装 CocoaPods\ngem 是 Ruby 的包管理器，Mac 自带 Ruby，直接用就行了。\n1 sudo gem install cocoapods 检验环境\n1 cordova requirements 如果没有任何报错，就没问题了。\n运行\n1 2 npm run build cordova run ios 报错: xcode-select: error: tool \u0026lsquo;xcodebuild\u0026rsquo; requires Xcode, but active developer directory \u0026lsquo;/Library/Developer/CommandLineTools\u0026rsquo; is a command line tools instance\n由于我一开始在我的 Mac 上安装环境的时候，单独安装了 Xcode 的 CommandlineTools，后面又安装 Xcode，我的机子上有两个 CommandlineTools。 而当前使用的那个 CommandlineTools 是不在 Xcode 下面的那个。\n我们需要更改一下 CommandlineTools 的目录：\n1 xcode-select -switch /Applications/Xcode.app/Contents/Developer/ Android 环境配置 安装 JDK\n一般来说，推荐使用 JDK 1.8。\n安装 Android Studio\n安装 Android SDK\n打开 Android Studio 的 SDK Manager。\n目前最新版的 cordova-android 是 9.0.0，刚刚支持了 Andorid 10( API 29 )，所以我们就安装 Android 10 就好了。\n早期版本的 cordova-android 和 android api 版本的关系可以去官网。\n创建虚拟设备\n打开 AVD Manager，选一下机型和系统镜像就好了，注意前面的安卓版本兼容。\n安装 Gradle\n首先，你需要一个 Gradle 命令行，直接用 brew 吧。( 安装半天 )\n1 brew install gradle 然后，现在你应该已经能通过 cordova requirements 的测试了，但是还没完。\n因为 Android 打包默认使用 gradle wrapper，所以它应该会下载一个版本的 gradle 到你的本地，路径在 ~/.gralde/wrapper/dists/gradle-xx-all/xxxxx/，建议立刻停止进程，然后自己另外下一个相同版本的替换它。\n把下载链接复制到迅雷，可以快速下载 gradle 包。\n运行\n先打开虚拟设备，然后运行:\n1 2 npm run build cordova run android 题外话 history 和 hash 模式 vue router 默认使用 hash模式，这项技术本质上就是 URL锚点 ，我们知道 vue 开发的 SPA 只有一个页面，页面跳转功能是模拟出来的，使用 URL锚点 在页面中跳转属于常规操作。\nhistory模式 利用了 HTML5 history interface，基于浏览器记录栈进行跳转，这种模式下的 URL 会更好看，更加符合直觉。\nhistory模式 有一个问题: 应用内跳转链接需要一个服务器来重定向到本地的文件上，对于单页面应用来说，也就是 index.html。\n我的建议是，如果是网页端开发的话，用 history模式 无疑是最好的，如果你的项目的目标是移动端的程序，最好用 hash模式。\n配置资源文件 找不到资源文件。因为 Vue 在引用资源文件的时候按绝对路径去寻找，可以把他们作为。这个有解决方案。\n新建 vue.config.js 文件:\n1 2 3 module.exports = { publicPath: \u0026#34;./\u0026#34;, }; 如何寻找Vue插件 开启 Vue 项目管理工具:\n1 vue ui 里面分为依赖和插件两部分。\n依赖一般是官方发布的，能保持最新，且 BUG 较少，就是配置起来麻烦。\n插件就是整合依赖的工具，质量参差不齐，但是插件可以做到开箱即用，很方便。只是有些插件的作者不是很上心，占着显眼的名字，质量却不如一些冷门的好。\n祝大家运行成功！\n","date":"2020-10-20T22:08:07+08:00","permalink":"https://nonlinearthink.github.io/p/cordova-vue-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%89%93%E5%8C%85/","title":"Cordova Vue 跨平台打包"},{"content":"像素思维 这一小节，我们将介绍 px(Pixel)。\n逻辑像素而不是物理像素 px 从字面上来看是像素的意思，很多新手一上来可能会认为它的物理像素。\n这里必须要澄清，px一般是指逻辑像素，它会根据浏览器、操作系统、硬件设备做适当的缩放。\n但是，通常96px对应了一个物理英寸。\n像素级的完美与响应式布局 最开始，px 被设计出来的时候所奉行的哲学就是提供像素级别的完美。\n早期的网页设计者会在一个固定大小的页面中设计网页，一般是 800px，你的浏览器如果超过来这个尺寸，必须用水平或者上下滚轮来浏览。每一个元素都是以像素为单位，被精确和巧妙地安排在这个页面中。\n随着高清显示屏的出现，人们开始考虑把网页调大到 1024px，甚至是 1280px，\n设备的种类越来越多，尺寸、像素等等都难以兼容。\n响应式布局是一种能根据屏幕的大小动态调整的布局方式，如今大部分网页都是响应式的，你几乎看不到非响应式的网页了，记得我小时候冲浪就经常遇到那种网页大小不兼容的。\n相对字号的大小单位 em 是一个非常有意思的属性。它是一个相对长度单位，相对于当前元素的字号，也就是相对于 font-size 的大小。\n计算方法 例如，假设已定义当前的 font-size 的大小为 16px ，padding 的大小为 1.2em ，则 padding 的实际大小是多少 px?\n1 2 3 4 .default { font-size: 16px; padding: 1.2em; } 这是一道简单的计算题，padding 的实际大小应该是 $16\\times1.2=19.2(px)$。\n字体大小相对于字体的大小 这是一个有趣的问题，既然 em 是相对于字体的大小单位，那么如果 字体font-size 的大小单位也是 em 会发生什么?\n这种情况下，参照对象不再是元素自身，而是父元素。\n1 2 3 \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;subcontainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 .container { font-size: 16px; } .subcontainer { font-size: 2em; } 假如父元素的 font-size 是 16px，子元素的 font-size 为 2em，则子元素的实际 font-size 应该为 32px。\n如果父元素没有特别说明，则会一直沿着 DOM树 向上，直到找到一个定义的字体大小为止，你始终可以找到一个定义的字体大小，因为浏览器会给根元素设置一个默认的固定的字体大小。\n浏览器默认字号 对每一个网页的根节点，我们一般使用 伪类选择器:root 来表示，也可以使用 html 来表示。\n大多数浏览器都定义了这个根元素的默认 font-size 为 16px。\n1 2 3 :root { font-size: 16px; } 字体缩小问题 关于 font-size 使用 em ，你应当尽量避免使用，这会造成一个问题，这里有一个比较有趣的例子。\n先做一个无序列表出来:\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; Top level \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; Second level \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; Third level \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 设置无序列表的字体为 0.8em，根据计算，无序列表里面的字体大小应该是 12.8px。\n1 2 3 ul { font-size: .8em; } 效果:\n为什么字体越来越小了？\n我们可以想象，根元素的字体大小是 16px，所以第一级无序列表是 12.8px 没问题，但是第二级无序列表的父元素是第一级无序列表，所以它的字体大小变成了 $12.8\\times0.8=10.24(px)$ 。第三极无序列表的字体大小: $10.24\\times0.8=8.192(px)$。\n字体随着层级越来越多，变得越来越失控。\n正式因为如此，我们一般不推荐使用 em 来定义字体大小，如果你一不小心，就可能造成这种悲剧。\n相对根元素字号的大小单位 根元素伪类选择器 伪类选择器:root，在 HTML 中对应的是 html 标签。\n设置默认字号 以前，网页设计者们为了方便计算，很喜欢利用这个伪类选择器这样写:\n1 2 3 :root { font-size: .875em; } 这是因为 $16\\times0.875=10(px)$，通过这种方式把根元素字号定义为 10px 后，接下来，基于根元素的字号计算可以变得简单一些。\n自定义属性 这是 CSS3 非常重要的一个特性，不过大多数人都会忽略，事实上，我们习惯了使用 SASS/Scss、Less 等等CSS预处理器之后，这个特性已经比较鸡肋了。\n1 2 3 4 5 6 7 8 9 :root { --main-font: Helvetica, Arial, sans-serif; --brand-color: #369; } p { font-family: var(--main-font); color: var(--brand-color) } 如果 var() 函数计算出来的是一个非法值，会设置成对应属性的初始值。\nrem-低复杂度的em rem 是 root rm 的缩写，前面已经介绍过 ，rem 是相对于根元素的字号大小，根元素也就是 :root，或者说是 html。\n1 2 3 4 5 6 7 :root { font-size: 16px; } ul { font-size: .8rem; } ul 的 font-size 大小经过计算是 12.8px。\n这个 css 代码可以解决上面我们的字体缩小问题。\n因为 rem 是相对于根元素字体的大小，就不会引起因为父子元素嵌套而造成的递推缩小现象。\n故此，rem 可以被认为是一种低复杂度的 em 。\n相对视图窗口的大小单位 视图窗口指的是浏览器视图的大小，在桌面端的浏览器中，你可以随意拖动鼠标来调节这个窗口的大小。\n主要涉及的元素是 vh 和 vw，很显然，他们分别是 visual hight 和 visual width 的缩写。\n单位 作用 备注 vh 视图窗口高度的$\\frac{1}{100}$ vw 视图窗口宽度的$\\frac{1}{100}$ vmin 视图窗口高度、宽度中较小一方的$\\frac{1}{100}$ 部分浏览器不支持 vmax 视图窗口高度、宽度中较大一方的$\\frac{1}{100}$ 部分浏览器不支持 你可以认为这些是百分比单位，他们的原子单位都是 1%。\n使用 vh 和 vw 定义字号 1 2 3 :root { font-size: 2vw; } 假设这是在一个 1200px 的显示屏上，字体的大小经过计算是 24px。\n而在一个 768px 的显示屏上，计算值是 15px。\n这实在是太棒了，这是动态可调节的字号。\n但是，如果你把浏览器的宽度放到很小，这太糟糕了，有没有可能设置一个最小值和最大值来限制这种现象？\n使用 calc() 函数 1 2 3 :root { font-size: calc(0.5em + 1vw); } 这个设计的巧妙之处在于，当你缩小到一定程度，1vw 的计算值几乎不可见的时候，0.5em 依然可以保证它至少有 8px 的大小，不至于小到看不见。\n响应式布局入门 响应式布局的精髓是对不同屏幕的适配，我们可以通过媒体查询来定义不同屏幕下的差异。\n媒体查询应当规定一些固定的值，作为后面所有元素的参照，后面所有的元素都应该使用相对单位，除了一些线条可以使用 px，其他一律不建议使用。\n这里只简单谈一些博主的经验，具体还要靠你们实践。\n媒体查询 在 CSS 中，也叫 @meida 规则，它可以指定某种屏幕尺寸或者媒体类型下的样式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 :root { font-size: 0.75em; } @media (min-width: 800px) { :root { font-size: 0.875em; } } @media (min-width: 1200px) { :root { font-size: 1em; } } 在宽度小于 800px 屏幕下，根元素 font-size 的计算值是 12px；\n在宽度大于 800px，但是小于 1200px 的屏幕下，根元素 font-size 的计算值是 14px；\n在宽度大于 1200px 屏幕下，根元素 font-size 的计算值是 16px；\n通过媒体查询，做到了不同屏幕的适配。\n使用大小单位的建议 为了防止布局的不可调整，我们有一些一般性的结论，来使用 CSS 提供的各种单位。\n使用 px 定义线 1 2 3 .default { border: 1px soild #999; } 使用 em 定义间距 1 2 3 .default { padding: 1em; } 使用 rem 定义字号 1 2 3 .default { font-size: 1rem; } 使用 vh 和 vw 定义容器 1 2 3 4 .default { height: 50vh; weight: 50vw; } ","date":"2020-07-08T14:49:49+08:00","permalink":"https://nonlinearthink.github.io/p/css-%E5%83%8F%E7%B4%A0%E5%92%8C%E5%8D%95%E4%BD%8D%E8%AE%A1%E7%AE%97/","title":"CSS 像素和单位计算"},{"content":"box-shadow 概述 先从整体来说说 box-shadow 属性 。\nbox-shadow 支持定义多个阴影，他们应该使用逗号分割:\n1 box-shadow: 3px 3px red, -1em 0 0.4em olive; 这里定义了两个阴影，分别是 3px 3px red、-1em 0 0.4em olive。\n其中，每个阴影支持最多6个字段:\ninset\n可选的字段，默认不指定。\n指定inset，阴影向内扩散，否则阴影向外扩散。\noffset-x 和 offset-y\n用来设置阴影偏移量，分为 x方向 和 y方向。声明的时候，x方向 在前，y方向 在后。\n这个定义的顺序是有讲究的，CSS 的偏移采用的是我们平时定义坐标轴的习惯，按照 (x,y) 的顺序，这个规则不仅仅适用于我们今天的主角 box-shadow ，而且基本上和\u0026quot;位移\u0026quot;、\u0026ldquo;偏移\u0026quot;有关的属性都适用。\n如果两者都是0，那么阴影不做偏移，位于元素正后方。\nblur-radius\n一般情况下，阴影是纯色的，没有渐变区域。\n但是如果设置了模糊半径，就会创建一个渐变区域，向周围的颜色过渡。\n渐变半径必须大于0。\nspread-radius\n扩散半径是对原来的纯色阴影的缩放。\n默认取值为0，代表阴影和物体一样大，但因为阴影在物体后面，所以你看不见。当然加上一层模糊半径你就能看到了。\n小于0的时候，阴影会缩小。这种情况下往往你也看不到，需要设置一层很厚的模糊半径，然后慢慢调低扩散半径你才能看出区别。\n大于0的时候，阴影会扩大。\ncolor\n阴影的颜色，这就不用解释了。\nbox-shadow 很简单，但是对于新手来说，在面对模糊半径和扩散半径可能会有点困惑，接下来，我们将结合例子，更加深入探讨这两者的区别。\n准备: 定义一个球 因为方形的不太适合我们的讲解，我们先定义一个圆形的球:\n1 2 3 4 5 6 7 .ball { height: 100px; width: 100px; border-radius: 50% 50%; margin: 50px; display: inline-block; } 外加一些阴影:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 .b1 { box-shadow: 0px 0px 20px #888; } .b2 { box-shadow: 0px 0px 20px 10px #888; } .b3 { box-shadow: 0px 0px 0px 10px #888; } .b4 { box-shadow: 0px 0px 20px -10px #888; } .b5 { box-shadow: inset 0px 0px 20px #888; } .b6 { box-shadow: inset 0px 0px 20px 10px #888; } .b7 { box-shadow: inset 0px 0px 0px 10px #888; } .b8 { box-shadow: inset 0px 0px 20px -10px #888; } 只有模糊半径 我们先定义一个没有扩散半径的球:\n1 2 \u0026lt;!-- box-shadow: 0px 0px 20px #888 --\u0026gt; \u0026lt;div class=\u0026#34;ball b1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 可以看到，球的周围有一圈阴影，因为我们没有设置扩散半径，所以我们看到的这层阴影应该是全部的模糊半径。\n我们还可以尝试使用一下内阴影:\n1 2 \u0026lt;!-- box-shadow: inset 0px 0px 20px #888 --\u0026gt; \u0026lt;div class=\u0026#34;ball b5\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 模糊半径+扩散半径(取正) 接下来我们尝试使用在原来的基础上添加一个扩散半径:\n1 2 3 4 \u0026lt;!-- box-shadow: 0px 0px 20px 10px #888 --\u0026gt; \u0026lt;div class=\u0026#34;ball b2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- box-shadow: inset 0px 0px 20px 10px #888 --\u0026gt; \u0026lt;div class=\u0026#34;ball b6\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 第一感觉应该是阴影增厚了，再仔细看，我们会发现，增厚的部分的阴影都很浓，也就是说，我们增厚的部分是纯色的阴影，而不是经过了模糊的渐变阴影，这就是所谓的扩散半径。\n只有扩散半径 我们可以把模糊半径去掉，看看差别:\n1 2 3 4 \u0026lt;!-- box-shadow: 0px 0px 0px 10px #888 --\u0026gt; \u0026lt;div class=\u0026#34;ball b3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- box-shadow: inset 0px 0px 0px 10px #888 --\u0026gt; \u0026lt;div class=\u0026#34;ball b7\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 看到了吗？阴影是纯色的，没有渐变。\n总结下来，模糊半径就是渐变阴影半径，而扩散半径就是纯色阴影半径。并且，渐变阴影包在扩散阴影外面。\n模糊半径+扩散半径(取负) 最后再看一个例子，是扩散半径为负数的时候:\n1 2 3 4 \u0026lt;!-- box-shadow: 0px 0px 20px -10px #888 --\u0026gt; \u0026lt;div class=\u0026#34;ball b4\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- box-shadow: inset 0px 0px 20px -10px #888 --\u0026gt; \u0026lt;div class=\u0026#34;ball b8\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 扩散半径为负数，就是把里面的那层纯色的半径减少了，也就是说，我们目前看到的是模糊半径的一小部分。\n大部分卡片UI的设计就是这种，你们可能很熟悉了，也是我个人觉得最好看的阴影。\n","date":"2020-06-28T00:32:28+08:00","permalink":"https://nonlinearthink.github.io/p/css-%E9%98%B4%E5%BD%B1-%E5%81%8F%E7%A7%BB%E6%A8%A1%E7%B3%8A%E5%8D%8A%E5%BE%84%E6%89%A9%E6%95%A3%E5%8D%8A%E5%BE%84/","title":"CSS 阴影: 偏移、模糊半径、扩散半径"},{"content":"JDBC (Java Database Connectivity) ，属于 Java 应用编程中比较基础的一块，虽然你可以直接使用 MyBatis，但是了解一下 JDBC 可以帮你更好地理解 Java 的数据库编程。\n连接数据库 驱动初始化 基于 Class.forName 的初始化 想要开始 JDBC 编程，第一步是需要把 数据库驱动程序 的代码加载进来。\n可以利用 Class.forName 函数，它原本的功能是返回一个 类或者接口的 Class 对象 ，也就是相当于初始化了一个类，一般用它执行这个类的静态代码段。\n1 2 3 4 5 try { Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); } catch (ClassNotFoundException e) { e.printStackTrace(); } 这样，com.mysql.jdbc.Driver 类中的静态代码段就会被执行，进行初始化。\n不过，驱动初始化还有另外一种写法。\n基于 registerDriver 的初始化 我们知道 Class.forName 是执行类的静态代码段，那我们把 com.mysql.jdbc.Driver 里面的静态代码段照着样子抄一遍不也可以实现初始化吗?\n这是 com.mysql.jdbc.Driver 静态代码段的源代码:\n1 2 3 4 5 6 7 static { try { java.sql.DriverManager.registerDriver(new Driver()); } catch (SQLException E) { throw new RuntimeException(\u0026#34;Can\u0026#39;t register driver!\u0026#34;); } } 这段代码可以完全代替上一小节的代码，我们可以认为 DriverManager.registerDriver(new Driver()) 和 Class.forName 的写法是等效的。\n什么是 数据库驱动程序 ？\nJDK 提供了一个 JDBC 的接口(Interface)。但是，因为是接口，所以还是没有实现的，每个数据库的厂商需要自己实现这个接口，这样用户才能正常调用。\n以 mysql 为例，下载地址: dev.mysql.com/downloads/connector/j\n接口变动\nmysql5 和 mysql6 的驱动程序接口有区别，从 com.mysql.jdbc.Driver 换成了 com.mysql.cj.jdbc.Driver，再往上的版本同 mysql6 。\n建立连接 数据库打开后会在本地开一个端口，运行进程，我们可以通过这个端口的 URL 来访问数据库。\n当然，还需要数据库的用户名和密码。\n1 java.sql.DriverManager.getConnection(url, user, password); JDBC 的 URL 格式: jdbc:[数据库连接名]://localhost:[端口号]/[数据库名]\n数据库连接名 mysql、sqlserver 端口号 3306(mysql)、1433(sqlserver) 数据库名 业务相关的数据库名，自定义 一个 JDBC 连接数据库的例子:\n1 2 3 4 5 6 try { java.sql.Connection conn = java.sql.DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/booklib\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;); } catch (SQLException e) { e.printStackTrace(); } JDBC 基础 Statement Statement 可以根据给出的一条 SQL 字符串，然后调用运行。\n借用上一节连接得到的 conn 对象，它有一个 createStatement 函数，可以创建一个 Statement。\n1 2 3 4 5 6 7 try { java.sql.Connection conn = java.sql.DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/booklib\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;); java.sql.Statement st = conn.createStatement(); } catch (SQLException e) { e.printStackTrace(); } execute、executeQuery、executeUpdate 创建完 Statement，就要把 SQL 语句交给 Statement 对象去执行了。\nexecuteQuery 一般如果是运行 查询(select) 语句，推荐使用 第一节中获得的conn 对象的 executeQuery 函数，executeQuery只能返回单个结果集，但是应对大部分的查询已经足够。\n添加下面的代码到上面的 try 代码块中。\n1 2 String sql = \u0026#34;select * from BeanBook\u0026#34;; st.executeQuery(sql); executeUpdate 如果你需要运行 insert、update、delete 等等语句，则可以使用 executeUpdate 函数，它不会返回结果集，但是会返回一个整数，代表受到影响的行数，如果是 0，代表了你没有改变任何数据库的内容，即调用失败了。\n使用 executeUpdate :\n1 2 String sql = \u0026#34;delete from BeanBook where price\u0026gt;50\u0026#34;; st.executeUpdate(sql); execute execute 是更加通用和强大的函数，但是它也比较复杂。它的返回值类型有很多。\nexecute 不仅可以做到 executeQuery 能做的事，也能做到 executeUpdate 能做到的事情。而且，它还能返回多个结果集。\n正因为如此，它一般被用在一些执行未知 SQL 字符串的情况下，如果 SQL 语句能够确定，请尽可能不用 execute。\n它的返回值比较复杂，我们一般使用 getResultSet 和 getUpdateCount 获取，而不是直接把 st.execute(sql); 的结果拿来。\n以下两段代码和上面两小节的 demo 的效果是一样的。\n1 2 3 4 5 6 7 8 9 //代码段1 String sql = \u0026#34;select * from BeanBook\u0026#34;; st.execute(sql); st.getResultSet(); //代码段2 String sql = \u0026#34;delete from BeanBook where price\u0026gt;50\u0026#34;; st.execute(sql); st.getUpdateCount(); ResultSet 前面一直没提 ResultSet，ResultSet 就是 executeQuery 的返回值。\n举个例子，使用 ResultSet 遍历 SQL 的结果:\n1 2 3 4 5 String sql = \u0026#34;select * from BeanBook\u0026#34;; java.sql.ResultSet rs = st.executeQuery(sql); while (rs.next()) { System.out.println(rs.getString(1) + \u0026#34;\\t\u0026#34; + rs.getString(2) + \u0026#34;\\t\u0026#34; + rs.getDouble(4)); } ResultSet 通过 next 函数来遍历，next 从一条记录跳转到下一条记录。\ngetString、getDouble 等等函数接受一个数字 n 作为参数，获得当前记录的第 n 个属性的值，并对这个值进行转换。\n比如 getString(1) 获取第一个属性，转换成 String 类型；getDouble(4) 获取第四个属性，转换成 Double 类型。\n下面是一些 get 函数 (不全):\n原始类型相关 getString、getBoolean、getByte、getShort、getInt、getLong、getFloat、getDouble 日期相关 getDate、getTime、getTimestamp PreparedStatement 通过 conn.prepareStatement 可以来创建一个 PrepareStatement 对象 (conn 是一个 java.sql.Connection)。\n但是这个函数必须要给出一个 SQL 语句作为参数。\n这里也可以看出 PrepareStatement 与 Statement 的一个比较大的区别。Statement 可以一直被复用，但是 PrepareStatement 每执行一次 SQL，都要创建新的 PrepareStatement。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //Statement java.sql.Statement st = conn.createStatement(); Int limit = 50; String sql = \u0026#34;delete from BeanBook where price\u0026gt;50\u0026#34;; st.executeUpdate(sql); String sql2 = \u0026#34;select * from BeanBook\u0026#34;; st.executeQuery(sql2); //PrepareStatement String sql = \u0026#34;delete from BeanBook where price\u0026gt;50\u0026#34;; java.sql.PreparedStatement pst = conn.prepareStatement(sql); st.executeUpdate(); String sql2 = \u0026#34;select * from BeanBook\u0026#34;; java.sql.PreparedStatement pst2 = conn.prepareStatement(sql2); st.executeQuery(); PreparedStatement 和 Statement 一样是用来执行 SQL 语句的，但是 Statement 有很多问题。\n字符串拼接问题 假如我们希望可以动态地设置 SQL 语句，比如，动态改变 where 从句的条件，在 Statement 中，我们需要这样写:\n1 2 3 4 java.sql.Statement st = conn.createStatement(); Int limit = 50; String sql = \u0026#34;delete from BeanBook where price\u0026gt;\u0026#34;+limit; st.executeUpdate(sql); PrepareStatement 允许一种可读性非常好的参数设置语法:\n1 2 3 4 String sql = \u0026#34;delete from BeanBook where price\u0026gt;?\u0026#34;; java.sql.PreparedStatement pst = conn.prepareStatement(sql); pst.setInt(1, 50); st.executeUpdate(sql); 这个 ? 语法可不止可读性好，还有一个更重要的是，它支持了 预编译，这在我们接下来提到的性能问题中会被具体讨论。\n还需要提一下的是 setInt 等等的 set 相关的函数，前面已经提过 get 函数了，基本上把 get 改成 set 就行了。\n性能问题 Statement 的想法是对象只需要创建一次，后续只要传入不同的 SQL 就行了。但是在面对重复都比较高的工作的时候，这可能并不是很好。\n比如，我执行了一次 insert into Beanbook(barcode, bookname, pubid, price, state) values(1, 'Java', 3, 56, '在库')，\n现在我稍微变一下，要插入 insert into Beanbook(barcode, bookname, pubid, price, state) values(2, 'C++', 2, 34, '在库')。\n这两条命令几乎一样，但是我却要编译两次!!!\n我们来看看 PrepareStaement，我们完全可以使用 ? 语法，创建一次模版，因为存在预编译机制，当我们第二次插入的时候节省了一次编译的开销。\n也就是说，在可以使用 ? 语法替换的一系列 SQL 操作中，使用 PrepareStatement 将会节省一大笔开销。\nSQL 注入式攻击 SQL 注入式攻击其实很简单，这是完全可以避免的，但是使用 Statement 的时候你要格外小心。\n假设不怀好意的用户对你的数据库请求删除一些合法的东西，比如删除 bookname 等于 'Java' 的书，但是他传给你的字符串做了一些手脚:\n1 2 3 4 5 //用户的数据 String name=\u0026#34;\u0026#39;Java\u0026#39; OR price\u0026gt;0\u0026#34;; //你的代码 String sql = \u0026#34;delete from BeanBook where bookname=\u0026#34;+name; 好了，你完了，因为字符串拼接的时候，后面的 OR price\u0026gt;0 没有被当作是 bookname 的一部分，而是被当成是 SQL 命令的一部分!!! 在这里，你的数据库已经被清空了。\n但是使用 ? 语法你完全不用担心，因为 PrepareStatement 是预编译的，后面只会插入数据，插入的内容不会被当作是 SQL 命令。\nclose 在数据库的最后不能忘记，关闭连接。\n在原先代码的基础上，在最后的 finally 语句块中加入 close() 函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static void main(String[] args) throws SQLException { java.sql.Connection conn = java.sql.DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/booklib\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;); try { conn.setAutoCommit(false); String sql = \u0026#34;select * from BeanBook\u0026#34;; java.sql.PreparedStatement pst = conn.prepareStatement(sql); pst.executeQuery(); } catch (SQLException e) { e.printStackTrace(); } finally { if (conn != null) try { conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } JDBC时间类型的处理 从之前的 get 函数中，我们看到了日期相关的 API。\nJDBC 中一共有三种时间类型:\nDate Time Timestamp System.currentTimeMillis() 这个函数可以获得 系统当前的一个时间戳。\n时间戳是 1970年1月1日0点0分 到现在的毫秒数。\n设置Timestamp 数据库里面存的都是 Timestamp，一般建议存取都用 Timestamp。\n设置当前的时间为 Timestamp:\n1 pst.setTimestamp(5, new java.sql.Timestamp(System.currentTimeMillis())); 通过 Date类 来创建 Timestamp:\n1 2 java.utl.Date date = new java.util.Date(); pst.setTimestamp(5, new java.sql.Timestamp(date.getTime())); 事实上，一般这里直接用字符串也能设置，但对于数据库存在性能问题，一般不建议这样做:\n1 pst.setString(5, \u0026#34;2020-06-27 00:00:00\u0026#34;); 取出Timestamp 因为从数据库直接取出的是 Timestamp，需要使用 SimpleDateFormat 来格式化，才能打印出我们可以识别的时间字符串。\n1 2 3 Timestamp timestamp = rs.getTimestamp(5); SimpleDateFormat sdf = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); System.out.println(sdf.format(timestamp)); 事务控制 为什么需要事务 一个事务是一系列用户定义的数据库操作序列(CRUD)。它的目的是把数据库的多个操作合并抽象成一个操作。\n事务的设计哲学: 要么都成功，要么都失败。这就是事务的原子性。\n事务是隔离的，并发执行的事务之间不互相干扰。\n如何实现 事务的实现靠的是回滚机制。\n当你做完一个操作的时候，都有日志文件记录下你修改的数据。如果你接下来的操作出现了问题，那么数据库就能根据日志文件，运行逆操作，回到原来的状态。\nJDBC中的事务编程 可以在最开始使用 setAutoCommit(false) 来关闭自动提交。\n所谓的自动提交就是，mysql 的 JDBC实现 默认是一旦运行了 execute 相关的那三个函数，就会自动运行 commit() 函数，以更新数据库。\n然后在 try 语句的最后使用 commit() 提交。\n最后不要忘记，异常处理，如果发生了异常，就要使用 rollback() 函数回滚，使前面的操作全部无效。\n我们来看一个结合来前面所有知识的例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import java.sql.SQLException; public class Test { static { try { Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); } catch (ClassNotFoundException e) { e.printStackTrace(); } } public static void main(String[] args) throws SQLException { java.sql.Connection conn = java.sql.DriverManager.getConnection(\u0026#34;jdbc:mysql://localhost:3306/booklib\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;); try { conn.setAutoCommit(false); String sql = \u0026#34;select * from BeanBook\u0026#34;; java.sql.PreparedStatement pst = conn.prepareStatement(sql); java.sql.ResultSet rs = pst.executeQuery(); while (rs.next()) { System.out.println(rs.getString(1) + \u0026#34;\\t\u0026#34; + rs.getString(2) + \u0026#34;\\t\u0026#34; + rs.getDouble(4)); } sql = \u0026#34;delete from BeanBook where price\u0026gt;50\u0026#34;; pst = conn.prepareStatement(sql); conn.commit(); } catch (SQLException e) { e.printStackTrace(); } finally { if (conn != null) try { conn.rollback(); conn.close(); } catch (SQLException e) { e.printStackTrace(); } } } } mysql 中的存储引擎有: InnoDB、MyISAM等等，但是事务控制只有 InnoDB 支持。\n连接池 连接池的概念 之前每次我们使用数据库 CRUD 的时候，我们每次都需要新建一个连接 Connection。\n创建连接和关闭连接的过程也是比较消耗时间的，当线程数量很大的时候，系统就会变得卡顿。\n连接池就是为了解决这个问题。连接池的设计哲学是: 总是借，而不创建。\n我们在一开始先创建一定数量的连接 Connection，然后每次有请求连接的时候，就找空闲的连接分配过去。如果没有空闲，则需要等待。\n实现连接池 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.util.ArrayList; import java.util.List; public class ConnectionPool { int size; List\u0026lt;Connection\u0026gt; conns = new ArrayList\u0026lt;Connection\u0026gt;(); public ConnectionPool(int size) { //构造器 this.size = size; init(); } public void init() { //初始化连接池 try { // Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); //mysql5 Class.forName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); // mysql6+ for (int i = 0; i \u0026lt; size; i++) { Connection conn = DriverManager .getConnection(\u0026#34;jdbc:mysql://127.0.0.1:3306/booklib\u0026#34;, \u0026#34;root\u0026#34;, \u0026#34;123456\u0026#34;); conns.add(conn); } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (SQLException e) { e.printStackTrace(); } } public synchronized Connection getConnection() { //获得一个连接 while (conns.isEmpty()) { try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } Connection conn = conns.remove(0); return conn; } public synchronized void returnConnection(Connection conn) { //返还一个连接 conns.add(conn); this.notifyAll(); } } 使用开源连接池(以 C3P0 为例) 一些著名的开源连接池\nDBCP C3P0 C3P0连接池 的使用:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import java.beans.PropertyVetoException; import java.sql.Connection; import java.sql.SQLException; import com.mchange.v2.c3p0.ComboPooledDataSource; public class ConnectionPoo { private static final String url=\u0026#34;jdbc:mysql://localhost:3306/booklib\u0026#34;; private static final String user=\u0026#34;root\u0026#34;; private static final String password=\u0026#34;123456\u0026#34;; private static ComboPooledDataSource dataSource; static{ try { dataSource = new ComboPooledDataSource(); dataSource.setUser(user); dataSource.setPassword(password); dataSource.setJdbcUrl(url); //dataSource.setDriverClass(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); dataSource.setDriverClass(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); dataSource.setInitialPoolSize(5); dataSource.setMinPoolSize(1); dataSource.setMaxPoolSize(10); dataSource.setMaxStatements(50); dataSource.setMaxIdleTime(60); } catch (PropertyVetoException e) { throw new RuntimeException(e); } } public static Connection getConnection() throws SQLException{ return dataSource.getConnection(); } } c3p0 v0.9.2版本 之后，从中分离了一个 mchange-commons-java 包，作为使用 c3p0 的辅助包。我们这里调用的就是辅助包。\nOR映射 JavaBean 一个 JavaBean 对象需要满足的条件:\n提供一个默认的无参构造函数。 需要被序列化并且实现 Serializable 接口。 一系列可读写属性。 一系列的 getter 或 setter 方法。 所有对 JavaBean 属性的访问都应当使用 getter 和 setter 方法。\nJavaBean 是一个可复用的组件，把应用的业务逻辑和显示逻辑分离开，降低了开发的复杂程度和维护成本。\nPOJO (Plain Ordinary Java Object) POJO 是纯粹的 JavaBean。\nJavaBean除了满足上面的条件，没有规定你不能定义其他东西，就算你把一些业务的代码加入进来也没关系。\nPOJO 不允许有业务方法，也不能携带 Connection 之类的方法。\n一个简单的 POJO 对象:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class BeanPublisher { private String pubid; private String publisherName; private String address; public String getPubid() { return pubid; } public void setPubid(String pubid) { this.pubid = pubid; } public String getPublisherName() { return publisherName; } public void setPublisherName(String publisherName) { this.publisherName = publisherName; } public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } EntityBean 与 OR映射 OR映射 是把数据库对象和编程语言中的对象映射在一起，他们拥有一样的属性。\nEntityBean 一般用于ORM对象关系映射，一个实体映射成一张表。\n它能执行很多自动化操作:\n创建一个 EntityBean 对象相当于创建一条记录 删除一个 EntityBean 对象会同时从数据库中删除对应记录 修改一个 EntityBean 时，容器会自动将 EntityBean 的状态和数据库同步 一些流行的 ORM 框架:\nHibernate MyBatis ","date":"2020-06-28T00:32:28+08:00","permalink":"https://nonlinearthink.github.io/p/jdbc-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/","title":"JDBC 数据库编程"},{"content":"因为几个月前买了一台 iPad，而我发现 iPad 最大的问题就是无法编程，所以打算自己搭建一个 jupyter notebook 的远程服务器，云服务器使用的是阿里云。\n我使用的是 Ubuntu 18.04 的镜像，对于其他 linux 服务器，可能也就是包管理器不一样而已。\n远程连接 root 账户。\n无论是本地使用 SSH 还是去阿里云的网站都可，无所谓。\n安装 pip3。\n1 apt install python3-pip 经测试，阿里云的 Ubuntu 18.04 自带 python3，但不带 pip3。\n安装 jupyter 和一些其他想要使用的库。\n1 2 3 pip3 install jupyter pip3 install matplotlib pip3 install sklearn 创建一个文件夹专门来放置 jupyter 的工作目录。\n1 2 3 4 5 6 cd /var/local mkdir jupyter cd jupyter mkdir home cd /var/log touch jupyter.log 生成 jupyter 配置和生成密码的 SHA 值。\n1 2 3 4 jupyter notebook --generate-config ipython \u0026gt; from notebook.auth import passwd \u0026gt; passwd() 注意复制下来，待会要用。\n使用 vim 修改 jupyter_notebook_config.py。\n1 vim ~/.jupyter/jupyter_notebook_config.py 在最后插入以下信息。\n1 2 3 4 5 6 c.NotebookApp.ip = \u0026#39;*\u0026#39; c.NotebookApp.allow_root = True c.NotebookApp.open_browser = False c.NotebookApp.port = 8888 c.NotebookApp.password = u\u0026#39;上面生成的sha值\u0026#39; c.ContentsManager.root_dir = \u0026#39;/var/local/jupyter/home\u0026#39; 安装 nbextensions\n原生 jupyter 的很多体验不是很好，推荐使用一个 jupyter 插件来弥补。\n1 2 3 pip3 install jupyter_contrib_nbextensions jupyter contrib nbextension install --user --skip-running-check jupyter nbextensions_configurator enable --user 先进入 jupyter 配置一下，勾选 Hinterland，这个是自动补全功能。虽然比较简陋，但是也很不错了。\n你可以看到这个插件还有很多其他的功能，可以自己探索一下。\n后台守护进程开启服务器。\n1 nohup jupyter notebook \u0026gt; /var/local/jupyter/runtime.log 2\u0026gt;\u0026amp;1 \u0026amp; 可能需要权限：\n1 nohup jupyter notebook --allow-root \u0026gt; /var/local/jupyter/runtime.log 2\u0026gt;\u0026amp;1 \u0026amp; 由于阿里云的限制，还需要配置一下安全策略。\n打开云服务器的实例界面，选择 本实例安全组-配置规则，可以看到下面的这个界面，添加一条规则就行了。\n在 Safari 中，打开服务器的 IP+端口号 8888。\n","date":"2020-05-10T12:01:48+08:00","permalink":"https://nonlinearthink.github.io/p/%E6%90%AD%E5%BB%BA-jupyter-notebook-%E4%BA%91%E7%AB%AF%E5%B7%A5%E4%BD%9C%E7%AB%99/","title":"搭建 Jupyter Notebook 云端工作站"},{"content":"环境变量 打印环境变量 环境变量就是程序运行时的一系列静态参数，程序在运行时无法修改。\n想要查看所有环境变量，可以使用这个命令：\n1 env 打印单个环境变量 几个比较常见的环境变量。\n变量名 说明 PATH shell将会去这里搜寻命令和程序 SHELL 当前使用的shell类型 HOME 当前用户的根目录 LOGNAME 当前用户的登录名 1 2 3 4 echo $PATH echo $SHELL echo $HOME echo $LOGNAME 定义环境变量 这是 Go 语言的一个环境变量配置。~/.bashrc 中添加下面几行。\n1 export GOROOT=/usr/local/Cellar/go/1.13.5/bin 保存退出后，就可以使用 echo $GOROOT 打印出来了。\n在一个目录下创建 .env 文件，并写入：\n1 GOROOT /usr/local/Cellar/go/1.13.5/bin 可以让这个环境变量仅对在当前目录下运行的应用程序生效。\n更改环境变量的值 有一个比较特殊的环境变量 $PATH，它是环境变量的一个路径集合，既然是集合就可以被不断添加。\n$PATH 以 : 分割，以 path/to/first:path/to/second 这样的形式存在。\n1 export PATH=$PATH:$GOROOT/bin 上面的命令相当于执行了一个 += 操作。也就是在原先的 $PATH 的基础上加上了 $GOROOT/bin。\nShell 配置文件 多用户配置 在 unix-like 系统中，系统配置文件都被放在一个叫 /etc 的目录下。其中也包含了 shell 配置文件。\nshell 配置文件可以分为两类: *profile 和 *shrc。\n*profile 中的内容会在用户登录时被运行。\n*shrc 会在 shell 启动时被运行。\n从生命周期的角度讲，写在 *profile 中的环境变量的生命周期是整个系统运行期间，而 *shrc 仅仅在 shell 被启动的时候才有效。\n生命周期长不一定好，因为我们可能不希望操作系统做太多的初始化而导致开机变慢，所以大部分我们用户自定义的环境变量都是在 *shrc 中。\n但是有些软件，需要他们一开机就运行，比如输入法，就需要写在 *profile 中。\n1 2 3 4 5 6 7 cd /etc ls *profile # output: # profile zprofile ls *shrc # output: # bashrc csh.cshrc zshrc 因为我安装了 zsh，所以多了 zprofile 和 zshrc，没安装过其他的 shell，只有默认的 bash 的话，应该只有 profile 和 bashrc。\n除此之外，忘记说了一点，/etc 文件夹下的配置是针对全部操作系统的用户的，所以请谨慎修改。\n单用户配置 上面说了多用户的环境变量配置，单用户的配置应该使用.bashrc 和 .bash_profile，它们在用户的根目录(~)下，默认是不创建的，如果需要则自己创建。\n1 2 3 4 5 6 7 cd ~ ls .*profile # output: # .bash_profile ls .*shrc # output: # .zshrc 我这里给 bash 创建了 profile，而给 zsh 创建了 shrc，其他没创建。\n值得注意的是，.bash_profile 在默认状态下，还会执行 .bashrc。\n环境变量的优先级 如果在 etc/profile 中和 ~/.bash_profile 都定义了相同的名字的环境变量，会发生什么？\n这个问题，我们可以从配置文件被加载的顺序来考虑。\n以 bash 为例。\n操作系统启动的时候，/etc/profile 被调用，然后 /etc/profile 调用 /etc/bashrc。 用户启动 shell 的时候，~/.bash_profile 被调用，然后 ~/.bash_profile 调用 ~/.bashrc。 最后被调用的会覆盖前面被调用的。\n补充 export 命令 export 命令就是设置环境变量。分两个场景来看：\n在命令行下\n在命令行下的 export 的作用域只有在这次登录期间。\n也就是说 shell 一旦退出，设置的环境变量就消失了。\n如果想要它一直存在，就要写到配置文件中。\n在配置文件中\n如果仔细看过上面的分析，就会知道配置文件是在 shell 登录时候自动加载的。\n自然就不会消失了。\nsource 命令 配置文件写入之后，环境变量不会马上更新。\nsource 命令可以加载一次配置文件的内容。\n比如，配置完上面的内容，使用 source：\n1 source .zshrc alias 命令 alias 就是别名，也就是为命令创建一个别名。\n比如，在 linux 中，python 往往默认是 python2。\n使用 alias 可以设置成 python3。\n1 alias python=python3 alias 也可以当成 export 用。\n区别在于，export 可以直接导入一个文件夹下面的全部可执行文件。\n而 alias 只能针对一个可执行文件，需要你一个一个写。\n1 alias mysql=/usr/local/mysql/bin/mysql 这样之后，我们每次用 mysql 的命令，就会被替换成 /usr/local/mysql/bin/mysql。\nalias 略微简洁明了一点，但其实优势并不是很大，一般都推荐用 export。\n","date":"2019-06-24T02:14:27+08:00","permalink":"https://nonlinearthink.github.io/p/linux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/","title":"Linux 环境变量的那些事"},{"content":"之前一直玩 ubuntu，今天体验了一把 manjaro KDE，界面相当舒适。\n但是，不像 ubuntu gnome 那样自带中文输入法，需要自己安装输入法。\n以 ibus输入法 为例，分享一下如何安装中文输入法。\n安装ibus 安装ibus软件包 1 $ sudo pacman -S ibus 查看所有可用的输入法 1 $ sudo pacman -Ss ^ibus-* 选择一个可用的输入法引擎并安装 1 $ sudo pacman -S ibus-pinyin 运行ibus 1 $ ibus-setup 发现出现提示：\n在 $HOME/.bashrc 中加入下面这段就好了\n1 2 3 export GTK_IM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus 添加中文输入法 上一步执行完成之后，就会出现这个界面，到这里添加中文输入法。\n安装过程中的其他问题 这个时候，突然发现每次开机都要在命令行中输入 ibus-setup 才能启动ibus。\n这样很麻烦，为了解决这个问题，原来我们把 $HOME/.bashrc 的内容：\n1 2 3 export GTK_IM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus 转移到 $HOME/.xprofile 中，并且在最后一行添加一条新的内容：\n1 2 3 4 export GTK_IM_MODULE=ibus export XMODIFIERS=@im=ibus export QT_IM_MODULE=ibus ibus-daemon -x -d 再重启发现输入法能开机自动启动了。\n","date":"2019-01-15T14:49:48+08:00","permalink":"https://nonlinearthink.github.io/p/manjaro-kde-%E5%AE%89%E8%A3%85-ibus-%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95/","title":"Manjaro KDE 安装 ibus 中文输入法"}]