[{"content":"求解绘制三角形问题 绘制三角形就是遍历每一个像素，然后，判断这个像素是否在三角形内部。\n但是万一，三角形很小，而屏幕很大，遍历每一个像素显然是非常低效的，在正式遍历前可以求出 Bounding Rect 来缩小范围：\n1 2 3 4 5 6 7 // Bounding Rect Vector2i min(0, 0); Vector2i max(width - 1, height - 1); min.x = std::max(min.x, std::min(p0.x, std::min(p1.x, p2.x))); min.y = std::max(min.y, std::min(p0.y, std::min(p1.y, p2.y))); max.x = std::min(max.x, std::max(p0.x, std::max(p1.x, p2.x))); max.y = std::min(max.y, std::max(p0.y, std::max(p1.y, p2.y))); 判断一个点是否在三角形内部，有很多方法，这里主要介绍重心坐标，因为这是图形学非常重要的一个知识点，而且也能非常好地解决这个问题。\n重心坐标（Barycentric Coordinate）的定义 假设平面上存在三角形的三个点 $a, b, c$，则平面上任意的点 $p$ 都可使用三角形的三个顶点表示：\n$$ \\begin{aligned} p \u0026amp;= a+\\beta(b-a)+\\gamma(c-a)\\cr p \u0026amp;= (1-\\beta-\\gamma)a+\\beta b+\\gamma c \\end{aligned} $$\n令：\n$$ \\begin{aligned} \\alpha \u0026amp;= 1-\\beta-\\gamma \\end{aligned} $$\n当 $\\alpha$、$\\beta$、$\\gamma$ 均大于 0 小于 1 时，$p$ 位于三角形内部 当 $\\alpha$、$\\beta$、$\\gamma$ 中有一个分量等于 0 时，$p$ 在三角形边上 当 $\\alpha$、$\\beta$、$\\gamma$ 中有两个变量等于 0 时，$p$ 在某个顶点上 以坐标形式表示：\n$$ p = (\\alpha, \\beta, \\gamma) $$\n重心坐标的计算 面积法 $$ \\begin{aligned} \\alpha = \\frac{A_a}{A_a+A_b+A_c} \\cr \\beta = \\frac{A_b}{A_a+A_b+A_c} \\cr \\gamma = \\frac{A_c}{A_a+A_b+A_c} \\end{aligned} $$\n求面积可以使用叉乘：\n$$ \\alpha = \\frac{A_a}{A} = \\frac{\\vert (c-b) \\times (c-p)\\vert}{\\vert (a-b) \\times (a-c)\\vert} $$\n但是求出来的 $\\alpha$ 失去了方向性。我们可以通过点乘一个法线来解决这个问题：\n$$ \\alpha = \\frac{((c-b) \\times (p-b))\\cdot n}{((b-a) \\times (c-a))\\cdot n} $$\n这个等式之所以成立的关键是两个向量 $a$、$b$ 的点乘表达式为： $$a\\cdot b = \\vert a\\vert\\vert b\\vert\\cos\\theta$$ 当它们相互垂直的时候，$\\cos\\theta = 1$，那么上面的表示式实际上可以被表达为： $$ \\alpha = \\frac{\\vert(c-b) \\times (p-b)\\vert \\vert n\\vert}{\\vert(b-a) \\times (c-a)\\vert \\vert n\\vert} = \\frac{\\vert(c-b) \\times (p-b)\\vert}{\\vert(b-a) \\times (c-a)\\vert} $$ 这个结果和之前的推导一样。\n同时我们从叉乘的定义中得到 $n = ab \\times ac$。\n最终，我们得到了最终结果：\n$$ \\begin{aligned} \\alpha \u0026amp;= \\frac{n_a \\cdot n}{n\\cdot n}\\cr \\beta \u0026amp;= \\frac{n_b \\cdot n}{n\\cdot n}\\cr \\gamma \u0026amp;= \\frac{n_c \\cdot n}{n\\cdot n} \\end{aligned} $$\n其中：\n$$ \\begin{aligned} n_a \u0026amp;= (c-b) \\times (p-b)\\cr n_b \u0026amp;= (a-c) \\times (p-c)\\cr n_c \u0026amp;= (b-a) \\times (p-a) \\end{aligned} $$\n代数法 把上一小节的公式，写成这样的形式：\n$$ \\beta(b-a)+\\gamma(c-a)+(a-p)= 0 $$\n分别带入 x 和 y，得到两个方程，求两个未知数：\n$$ \\begin{aligned} (x_b - x_a)\\beta+(x_c - x_a)\\gamma+(x_a - x_p) \u0026amp;= 0\\cr (y_b - y_a)\\beta+(y_c - y_a)\\gamma+(y_a - y_p) \u0026amp;= 0 \\end{aligned} $$\n最终的结果:\n$$ \\begin{aligned} \\gamma \u0026amp;= \\frac{(y_a-y_b)x_p+(x_b-x_a)y_p+x_a y_b-x_b x_a}{(y_a-y_b)x_c+(x_a-x_b)y_c+x_a y_b-x_b x_a}\\cr \\beta \u0026amp;= \\frac{(y_a-y_c)x_p+(x_c-x_a)y_p+x_a y_c-x_c x_a}{(y_a-y_c)x_b+(x_c-x_a)y_b+x_a y_c-x_c x_a}\\cr \\alpha \u0026amp;= 1-\\gamma-\\beta \\end{aligned} $$\n上面是标准的求法，还有一种捷径。\n把上面两个方程变成矩阵形式：\n$$ \\begin{aligned} \\begin{bmatrix} x_b - x_a \u0026amp; x_c - x_a \u0026amp; x_a - x_p \\cr \\end{bmatrix} \\begin{bmatrix} \\beta \\cr \\gamma \\cr 1 \\end{bmatrix} \u0026amp;= 0\\cr \\begin{bmatrix} y_b - y_a \u0026amp; y_c - y_a \u0026amp; y_a - y_p\\cr \\end{bmatrix} \\begin{bmatrix} \\beta \\cr \\gamma \\cr 1 \\end{bmatrix} \u0026amp;= 0 \\end{aligned} $$\n说明向量 $\\begin{bmatrix}x_b - x_a \u0026amp; x_c - x_a \u0026amp; x_a - x_p \\end{bmatrix}$ 垂直于向量 $\\begin{bmatrix}\\beta \u0026amp;\\gamma \u0026amp; 1\\end{bmatrix}$，向量 $\\begin{bmatrix}y_b - y_a \u0026amp; y_c - y_a \u0026amp; y_a - y_p \\end{bmatrix}$ 垂直于向量 $\\begin{bmatrix}\\beta \u0026amp;\\gamma \u0026amp; 1\\end{bmatrix}$。\n得到：\n$$ \\begin{bmatrix} x_b - x_a \\cr x_c - x_a \\cr x_a - x_p \\end{bmatrix}\\times \\begin{bmatrix} y_b - y_a \\cr y_c - y_a \\cr y_a - y_p \\end{bmatrix}= \\begin{bmatrix} k\\beta \\cr k\\gamma \\cr k \\end{bmatrix} $$\n这是最快的重心计算法，它只使用了一个叉乘就解决了问题。\n重心坐标代码实现 根据上面推导的公式，最终，代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 for (int y = min.y; y \u0026lt;= max.y; y++) { for (int x = min.x; x \u0026lt;= max.x; x++) { Vector3i vx(p1.x - p0.x, p2.x - p0.x, p0.x - x); Vector3i vy(p1.y - p0.y, p2.y - p0.y, p0.y - y); Vector3i u = vx.Cross(vy); if (std::abs(u.z) \u0026lt; 1) { continue; } Vector3f barycentric(1.f - (u.x + u.y) / (float)u.z, u.x / (float)u.z, u.y / (float)u.z); if (barycentric.x \u0026gt; 0 \u0026amp;\u0026amp; barycentric.x \u0026lt; 1 \u0026amp;\u0026amp; barycentric.y \u0026gt; 0 \u0026amp;\u0026amp; barycentric.y \u0026lt; 1 \u0026amp;\u0026amp; barycentric.z \u0026gt; 0 \u0026amp;\u0026amp; barycentric.z \u0026lt; 1) { PutPixel(Vector2i(x, y), color); } } } 参考资料 Fundamentals of Computer Graphics 三角形重心坐标 ","date":"2023-12-12T16:42:50+08:00","permalink":"https://nonlinearthink.github.io/p/%E7%BC%96%E5%86%99%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8%E5%9B%9B%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2/","title":"编写光栅化渲染器（四）绘制三角形"},{"content":"DDA Line DDA(Digital Differential Analyzer) 正如其名，就是最直观的直线画法，原始的算法的描述如下：\n假设存在屏幕空间上的两个点 $(x1, y1)$ 和 $(x2, y2)$\n计算 $dx=x2-x1$，$dy=y2-y1$。 计算斜率 $k=\\frac{dy}{dx}$。 x 从 x1 出发，每次向 x2 移动一个单位，计算 $y=y1+k(x–x1)$。 1 2 3 4 5 6 7 8 9 10 11 12 void DDA(int x0, int y0, int x1, int y1) { // 计算 dx \u0026amp; dy \u0026amp; k int dx = x1 - x0; int dy = y1 - y0; float k = dy / dx; // 循环绘制每一个像素 for (int x = x1; x \u0026lt;= x2; x++) { putpixel(x, round(y1 + k * (x - x1)), RED); } } 原始算法看起来很可靠，但是仍然有一些可以优化的地方，因为直线是线性且均匀的，所以假如提前计算好了每一次循环的增量，就可以避免 y1 + k * (x - x1) 中的浮点数乘法。\n优化过后的 DDA 算法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void DDA(int x0, int y0, int x1, int y1) { // 计算 dx \u0026amp; dy int dx = x1 - x0; int dy = y1 - y0; // 计算需要计算多少步像素 int steps = abs(dx) \u0026gt; abs(dy) ? abs(dx) : abs(dy); // 计算 x \u0026amp; y 每一步的增量 float xinc = dx / (float)steps; float yinc = dy / (float)steps; // 循环绘制每一个像素 float x = x0; float y = y0; for (int i = 0; i \u0026lt;= steps; i++) { putpixel(round(x), round(y), RED); x += xinc; y += yinc; } } Bresenham\u0026rsquo;s Line 从上面 DDA 的优化案例可以看出，避免浮点数操作就是优化画线算法的关键。\nBresenham's Line 相比 DDA 不仅有更少的浮点数运算，而且没有浮点数和整数的类型转换。\n算法的核心思想如下：\n在 $(x_k, y_k)$ 的位置时候，可能走向 $(x_k+1, y_k)$ 也可能走向 $(x_k+1, y_k+1)$，显然，斜线的交点更加靠近谁，就往哪个方向走。\n斜率:\n$$ k = \\frac{\\Delta y}{\\Delta x} $$\n对于每一次循环，执行：\n$$ x_{i+1} = x_i + 1\\ e_{i+1} = e_i + k\\ $$\n同时，始终保证 $0 \u0026lt; e \u0026lt; 1$：\n$$ e_{i+1} = e_{i+1} - 1, e_{i+1} \u0026gt; 1 $$\n最后，得出这个点的 y：\n$$ y_{i+1} = \\begin{cases} y_i+1 \u0026amp;\\text{if } e_{i+1} \\gt 0.5\\cr y_i \u0026amp;\\text{if } e_{i+1} \\le 0.5\\cr \\end{cases} $$\n上面的算法是 Bresenham's Line 的基本思想，还需要进一步优化，减少浮点数运算。\n可能产生浮点数的地方是 $k = \\frac{\\Delta y}{\\Delta x}$ 和 $e_{i+1} \\gt 0.5$，所以我们最后再把上面所有的过程乘以 $2\\Delta x$。\n最终，我们的代码如下，其中 $\\Delta x = x_2 - x_1, \\Delta y = y_2 - y_1$：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void bresenham(int x1, int y1, int x2, int y2) { int m = 2 * (y2 - y1); int slope_error = m - (x2 - x1); for (int x = x1, y = y1; x \u0026lt;= x2; x++) { putpixel(x, y, RED); slope_error += m; if (slope_error \u0026gt;= 0) { y++; slope_error -= 2 * (x2 - x1); } } } 最后的代码虽然看起来简洁，但是因为优化过，第一次接触容易摸不着头脑。\n其他算法 还有一种叫 Mid-Point Line ，因为它即没有 DDA 简单直接，也没有 Bresenham 效率高，这里就不介绍了。\n","date":"2023-12-08T23:12:03+08:00","permalink":"https://nonlinearthink.github.io/p/%E7%BC%96%E5%86%99%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B8%89%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF/","title":"编写光栅化渲染器（三）绘制直线"},{"content":"我们的第一个目标就是创建一个窗口，创建窗口有很多库都能做，如果你不想要用任何第三方库也不需要跨平台，用 Win32 API 就可以做，不过微软的匈牙利命名法实在是抽象，要有心里准备。\nSDL 库简介 SDL (Simple DirectMedia Layer) 是一个开源、跨平台、轻量级的多媒体层，作者目前在 Valve 任职，也就是大家最喜欢的 Steam，我们基本上只需要用到 SDL_Window 和 SDL_Surface 就可以。\n这里默认大家拥有 C++ 和 CMake 基础，不介绍怎么安装这个库了，直接开始。\n创建 Window 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #define SDL_MAIN_HANDLED #include \u0026#34;SDL.h\u0026#34; int main(int argc, char* argv[]) { // 定义窗口大小 const int width = 640; const int height = 480; // SDL 初始化 if (SDL_Init(SDL_INIT_EVENTS) \u0026lt; 0) { SDL_Log(\u0026#34;SDL init failed\u0026#34;); return 1; } // 创建 SDL 窗口 SDL_Window* window = SDL_CreateWindow( \u0026#34;SoftRenderer\u0026#34;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, wWidth, wHeight, SDL_WINDOW_SHOWN); if (!window) { SDL_Log(\u0026#34;create window failed\u0026#34;); SDL_Quit(); return 1; } // 一直循环，直到触发了 SDL_QUIT 事件（窗口被关闭） bool isQuit = false; SDL_Event event; while (!isQuit) { while (SDL_PollEvent(\u0026amp;event)) { if (event.type == SDL_QUIT) { isQuit = true; } } } // 释放资源 SDL_DestroyWindow(window); SDL_Quit(); return 0; } 这是一个最简单的 SDL 创建窗口的程序。\nSDL CPU 渲染：获取和更改 Surface 从 Window 可以获取一个 Surface，它和 Window 的大小相同高，并且它里面有一个 pixels 指针，可以访问每一个像素的数据。\n1 2 3 4 5 6 7 8 9 10 while (!isQuit) { ... // 获取窗口的 Surface SDL_Surface* surface = SDL_GetWindowSurface(window); // 像素数据在 surface-\u0026gt;pixels 中 // 更改 Surface 颜色 SDL_FillRect(surface, NULL, SDL_MapRGB(surface-\u0026gt;format, 0, 255, 0)); // 更新窗口的 Surface SDL_UpdateWindowSurface(window); } 从 Window 获取的 Surface 的格式可能并不是我们想要的。\n默认的 Window Surface 每一个像素是 32 位，但是实际上用的只有 24 位，我们就需要给每个像素写入这样：\n1 0x00FF0000 // RGB 红色 因为计算机中存储非 2 的幂次大小的数据会有性能问题，所以 SDL 这里数据是 32 位的，实际使用却是 24 位，头两位是无意义的。\n我们可能更希望使用 RGBA 格式的数据，RGBA 刚好就是 32 位：\n1 0xFF0000FF // RGBA 红色 这个时候我建议自己额外建一个 Surface，渲染完之后再更新给 Window 的 Surface。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 while (!isQuit) { ... // 创建 RGBA 的 render surface SDL_Surface* render_surface = SDL_CreateRGBSurfaceWithFormat( 0, width, height, 32, SDL_PIXELFORMAT_RGBA8888); // 渲染 render surface SDL_FillRect(render_surface, NULL, SDL_MapRGBA(surface-\u0026gt;format, 0, 255, 0, 255)); // 获取 window surface SDL_Surface* window_surface = SDL_GetWindowSurface(window); // 更新 render surface 到 window surface SDL_BlitSurface(render_surface, NULL, window_surface, NULL); // 更新 window surface 到 screen SDL_UpdateWindowSurface(window); // 释放 render surface SDL_FreeSurface(render_surface); } SDL GPU 渲染：Renderer 和 Texture 这一小节为补充内容，如果目标是做 CPU 的软渲染器，不需要了解。\n在 SDL 中，有两种方法可以去做渲染图形，一种是通过 SDL_Surface，另外一种是通过 SDL_Texture。\n区别在于 SDL_Surface 是在 CPU 中，而 SDL_Texture 在 GPU 中。\n使用 GPU 渲染必须要先创建 Renderer：\n1 2 3 4 5 6 SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, 0); if (!renderer) { SDL_Log(\u0026#34;create renderer failed.\u0026#34;); SDL_Quit(); return 1; } 还需要创建一张 Texture，我们不会直接绘制 Renderer，而是绘制在 Texture 上，在计算机图形学中，这种图像绘制在纹理上而不是屏幕上的技术叫做 Render Target Texture。\n1 2 3 4 5 6 7 SDL_Texture* rtt = SDL_CreateTexture(app-\u0026gt;_renderer, SDL_PIXELFORMAT_RGBA8888, 0, width, height); if (!rtt) { SDL_Log(\u0026#34;create renderer target texture failed.\u0026#34;); SDL_Quit(); return 1; } 每帧调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 while (!isQuit) { ... // 设置默认背景颜色 SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); // 清空屏幕 SDL_RenderClear(renderer); // 创建一个 Surface 来更改像素 SDL_Surface* surface = SDL_CreateRGBSurfaceWithFormat( 0, width, height, 32, SDL_PIXELFORMAT_RGBA8888); // 渲染，更改像素 SDL_FillRect(surface, NULL, SDL_MapRGBA(surface-\u0026gt;format, 0, 255, 0, 255)); // 更新 Surface 到 Texture 上 SDL_UpdateTexture(rtt, NULL, surface-\u0026gt;pixels, surface-\u0026gt;pitch); SDL_FreeSurface(surface); // 覆盖 Texture 到 Renderer 里面 SDL_RenderCopy(renderer, rtt, NULL, NULL); // 发送数据到 GPU SDL_RenderPresent(renderer); } 改写 C 风格的代码 SDL 是一个 C 的库，而不是 C++，这样风格的代码在 C++ 中是不安全和不便利的。所以我们需要做一些改造。\n使用智能指针 SDL 中有很多成对的比如 SDL_CreateWindow 和 SDL_DestroyWindow 函数。如果我们能自动释放就好了，可以用智能指针来解决这个问题。\n尝试重写智能指针的 Deleter：\n1 2 3 4 struct SDL_Window_Deleter { void operator()(SDL_Window* window) const { SDL_DestroyWindow(window); } }; using Unique_SDL_Window_Ptr = std::unique_ptr\u0026lt;SDL_Window, SDL_Window_Deleter\u0026gt;; 使用起来也格外方便：\n1 2 3 Unique_SDL_Window_Ptr window = Unique_SDL_Window_Ptr(SDL_CreateWindow( \u0026#34;SoftRenderer\u0026#34;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, width, height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE)); 尝试自己实现 SDL_Surface 的 Deleter\n使用 Class 封装 之前的 SDL 代码大致可以分为两个部分，一个是在 while 循环之前的初始化阶段，还有一个是在 while 循环内部的每帧执行阶段。\n1 2 3 4 5 6 7 8 RenderApplication app(width, height); if (!app-\u0026gt;InitApplication()) { return 1; } while (app-\u0026gt;running) { app-\u0026gt;Tick(); } 最终，RenderApplication 长这个样子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class RenderApplication { public: int width, height; bool running; RenderApplication(int _width, int _height) : width(_width), height(_height), running(true) { renderer_ = std::make_unique\u0026lt;SoftRenderer::Renderer\u0026gt;( width, height, SoftRenderer::Color::Black()); } ~RenderApplication() { // 这里不需要释放，因为 window 会释放它 window_surface_ = nullptr; SDL_Quit(); } bool InitApplication() { if (SDL_Init(SDL_INIT_EVENTS) \u0026lt; 0) { SDL_Log(\u0026#34;SDL init failed\u0026#34;); return false; } window_ = Unique_SDL_Window_Ptr(SDL_CreateWindow( \u0026#34;SoftRenderer\u0026#34;, SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, width, height, SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE)); if (!window_) { SDL_Log(\u0026#34;create window failed.\u0026#34;); SDL_Quit(); return false; } window_surface_ = SDL_GetWindowSurface(window_.get()); event_ = std::make_unique\u0026lt;SDL_Event\u0026gt;(); return true; } void Tick() { while (SDL_PollEvent(event_.get())) { if (event_-\u0026gt;type == SDL_QUIT) { running = false; return; } } // 渲染前的准备 Unique_SDL_Surface_Ptr render_surface(SDL_CreateRGBSurfaceWithFormat( 0, width, height, 32, SDL_PIXELFORMAT_RGBA8888)); renderer_-\u0026gt;PrepareRender((Uint32*)render_surface-\u0026gt;pixels); // 清空屏幕 renderer_-\u0026gt;Clear(); // 自定义渲染函数 render(); // 更新 renderer surface 到 window surface SDL_BlitSurface(render_surface.get(), NULL, window_surface_, NULL); // 更新 window surface 到 screen SDL_UpdateWindowSurface(window_.get()); // 保持稳定的帧数 SDL_Delay(1000 / 60); } virtual void render() {} protected: std::unique_ptr\u0026lt;SoftRenderer::Renderer\u0026gt; renderer_; Unique_SDL_Window_Ptr window_; SDL_Surface* window_surface_; std::unique_ptr\u0026lt;SDL_Event\u0026gt; event_; }; ","date":"2023-12-05T12:08:06+08:00","permalink":"https://nonlinearthink.github.io/p/%E7%BC%96%E5%86%99%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8%E4%BA%8Csdl%E5%BA%93%E7%AE%80%E4%BB%8B/","title":"编写光栅化渲染器（二）SDL库简介"},{"content":"光栅化 VS 光线追踪 对图形学稍微有了解的小伙伴应该知道，现在的实时渲染领域用的主要都是 Rasterization(光栅化)，而不是 Ray Tracing(光线追踪)，主要原因是实时渲染需要保证帧数稳定在 30 帧以上，而 Ray Tracing 需要非常庞大的计算量，完全不是多少 ms 之内能计算完的。\n等完成 编写光栅化渲染器 这个系列之后有一个关于 Ray Tracing 的新系列。\n屏幕由一个一个像素构成，每一个像素都可以被认为是一个小网格（实际上从物理结构上来讲并不是完全正方形的）\n那么如果要渲染一个场景，只需要把每一个网格填上颜色就可以了，光栅化实际上就是在聊怎么填颜色这件事情。比如你需要对场景里的物体进行排序，离相机近的物体表面颜色就是你想要绘制的图形的颜色。\n光线追踪技术则是基于物理，从一个像素点出发，经过多次反射，得到最终颜色，但是一个像素一条射线远远不够，因为这样误差会很大，往往一个像素需要数百条射线的结果求平均。\n光线追踪的本质就是对场景不断进行采样以降低噪点，最终得到最接近真实的图像。\n从时间复杂度来说，光栅化无疑比光线追踪来得更加好，但是因为缺少严谨的物理模型，光栅化的效果比光线追踪差很多，所以在对性能要求不高，但是对效果要求高的离线渲染中，光线追踪被普遍运用。\n截至文章编写日期，已经有游戏比如 赛博朋克2077 2.0 运用了 Path Tracing 技术，也叫 Monte Calo Ray Tracing，比传统的 Whitted Style Ray Tracing 性能更加好，效果也更棒。\n光栅化程序开发流程 创建一个窗口，并绘制直线，三角形，带有顶点数据的物体。 施工中\u0026hellip;\nReference Fundamentals of Computer Graphics\n","date":"2023-12-02T14:15:23+08:00","permalink":"https://nonlinearthink.github.io/p/%E7%BC%96%E5%86%99%E5%85%89%E6%A0%85%E5%8C%96%E6%B8%B2%E6%9F%93%E5%99%A8%E4%B8%80%E6%A6%82%E8%BF%B0/","title":"编写光栅化渲染器（一）概述"},{"content":"因为几个月前买了一台 iPad，而我发现 iPad 最大的问题就是无法编程，所以打算自己搭建一个 jupyter notebook 的远程服务器，云服务器使用的是阿里云。\n我使用的是 Ubuntu 18.04 的镜像，对于其他 linux 服务器，可能也就是包管理器不一样而已。\n远程连接 root 账户。\n无论是本地使用 SSH 还是去阿里云的网站都可，无所谓。\n安装 pip3。\n1 apt install python3-pip 经测试，阿里云的 Ubuntu 18.04 自带 python3，但不带 pip3。\n安装 jupyter 和一些其他想要使用的库。\n1 2 3 pip3 install jupyter pip3 install matplotlib pip3 install sklearn 创建一个文件夹专门来放置 jupyter 的工作目录。\n1 2 3 4 5 6 cd /var/local mkdir jupyter cd jupyter mkdir home cd /var/log touch jupyter.log 生成 jupyter 配置和生成密码的 SHA 值。\n1 2 3 4 jupyter notebook --generate-config ipython \u0026gt; from notebook.auth import passwd \u0026gt; passwd() 注意复制下来，待会要用。\n使用 vim 修改 jupyter_notebook_config.py。\n1 vim ~/.jupyter/jupyter_notebook_config.py 在最后插入以下信息。\n1 2 3 4 5 6 c.NotebookApp.ip = \u0026#39;*\u0026#39; c.NotebookApp.allow_root = True c.NotebookApp.open_browser = False c.NotebookApp.port = 8888 c.NotebookApp.password = u\u0026#39;上面生成的sha值\u0026#39; c.ContentsManager.root_dir = \u0026#39;/var/local/jupyter/home\u0026#39; 安装 nbextensions\n原生 jupyter 的很多体验不是很好，推荐使用一个 jupyter 插件来弥补。\n1 2 3 pip3 install jupyter_contrib_nbextensions jupyter contrib nbextension install --user --skip-running-check jupyter nbextensions_configurator enable --user 先进入 jupyter 配置一下，勾选 Hinterland，这个是自动补全功能。虽然比较简陋，但是也很不错了。\n你可以看到这个插件还有很多其他的功能，可以自己探索一下。\n后台守护进程开启服务器。\n1 nohup jupyter notebook \u0026gt; /var/local/jupyter/runtime.log 2\u0026gt;\u0026amp;1 \u0026amp; 可能需要权限：\n1 nohup jupyter notebook --allow-root \u0026gt; /var/local/jupyter/runtime.log 2\u0026gt;\u0026amp;1 \u0026amp; 由于阿里云的限制，还需要配置一下安全策略。\n打开云服务器的实例界面，选择 本实例安全组-配置规则，可以看到下面的这个界面，添加一条规则就行了。\n在 Safari 中，打开服务器的 IP+端口号 8888。\n","date":"2020-05-10T12:01:48+08:00","permalink":"https://nonlinearthink.github.io/p/%E6%90%AD%E5%BB%BA-jupyter-notebook-%E4%BA%91%E7%AB%AF%E5%B7%A5%E4%BD%9C%E7%AB%99/","title":"搭建 Jupyter Notebook 云端工作站"}]